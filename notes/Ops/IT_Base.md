# 通信互联

## 协议基础

### TCP/IP

#### TCP的三次握手与四次挥手

- ***TCP/IP数据包：***

![img](https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

序号(seq)：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。

确认号(ack)：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

| 字段 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| URG  | 标识紧急指针是否有效。1,表示某一位需要被优先处理。           |
| ACK  | 标识确认号是否有效。1,表示确认号字段有效。                   |
| PSH  | 提示接收端应用程序立即从TCP缓冲区把数据读走。                |
| RST  | 对方要求重新建立连接，复位。                                 |
| SYN  | 1建立连接（SYN=1 ACK=0表示一个连接请求报文段;SYN=1 ACK=1响应报文段），SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 |
| FIN  | 断开连接。1，表示：此报文段的发送方的数据已经发送完毕，并要求释放连接。 |

- ***三次握手过程理解：***

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 请求建立连接

   客户端发送syn包（syn=x）到服务器，并进入**SYN_SENT**状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

2. 同意建立连接

   服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入**SYN_RECV**状态；

3. 连接建立

   客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入**ESTABLISHED**（TCP连接成功）状态，完成三次握手。

- ***四次挥手过程理解：***

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. C 请求告别

   C 停止发送数据并请求释放连接，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。此时，客户端进入FIN-WAIT-1（终止等待1）状态。

2. S 确认收到并准备告别

   S 收到释放连接请求，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。

   C 收到 S 的确认请求，进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文。

   （该阶段C 不再发送数据，但依然要接收 S 发送的数据，持续整个CLOSE-WAIT状态）

3. S 同意告别

   S 将最后的数据发送完毕后，就向 C 发送连接释放报文，FIN=1，ack=u+1。服务器就进入了LAST-ACK（最后确认）状态，等待 C 的确认。

4. C 确认告别

   客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。

   注：此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

   服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。



**扩展：常见面试题**

1）为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

2）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

3）为什么不能用两次握手进行连接？

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

三次握手改成两次握手，可能造成死锁问题。如：假定计算机S和C之间的通信，C给S发送一个连接请求，S收到了这个请求，并发送了确认。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据。但如果C没有收到S的确认包，C认为连接还未建立成功，将忽略S发来的任何数据，只等待连接确认应答。而S在发出的数据包超时后，重复发送同样的数据包。这样就形成了死锁。

4）如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。





# Linux系统

## Linux 日志文件

| 日志文件          | 文件说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| /var/log/messages | 记录 Linux 内核消息及各种应用程序的公共日志信息，包括启动、I/0 错误、网络错误、程序故障等。 |
| /var/log/cron     | 记录 crond 计划任务产生的事件信息。                          |
| /var/log/dmesg    | 记录 Linux 操作系统在引导过程中的各种事件信息。              |
| /var/log/maillog  | 记录进入或发出系统的电子邮件活动。                           |
| /var/log/lastlog  | 记录每个用户最近的登录事件。                                 |
| /var/log/secure   | 记录用户认证相关的安全事件信息。                             |
| /var/log/wtmp     | 记录每个用户登录、注销及系统启动和停机事件。                 |
| /var/log/btmp     | 记录失败的、错误的登录尝试及验证事件。                       |







# Linux 故障排查

## 孤儿socket过多导致负载高

参考：<https://www.dyxmq.cn/network/tcpip/out-of-socket-memory.html>

### 什么是孤儿socket

官方说法：孤儿socket是已经没有和文件句柄绑定、但是仍然存在于内核没有被释放的socket。

结合TCP四次挥手理解：

![一次孤儿socket过多导致负载高的问题排查过程](https://www.dyxmq.cn/wp-content/uploads/2020/03/f288e-imagebe66dd8295b935ad.png)

客户端执行`close()`函数来关闭socket，并发送`FIN`包到服务端，客户端socket的状态是FIN-WAIT-1；

客户端等到收到服务端ACK后状态变成FIN-WAIT-2；

客户端等到收到服务端FIN后状态变成TIME-WAIT；（服务端收到客户端ACK关闭连接）

客户端等到2MSL时间过去后才变成CLOSED。

孤儿socket指的是状态在**FIN-WAIT-1**到**TIME-WAIT**之间的socket，即执行`close()`等待`CLOSED`的socket。









### 扩展：CPU性能检测工具mpstat

多CPU环境下，显示各个可用CPU的状态信息。

***Usage:***

```shell
mpstat(选项)(参数)
# 选项
-P	指定CPU编号，ALL表示所有CPU
# 参数
间隔时间：每次报告的时间间隔（秒）
次数：指定报告的次数
不带参数：输出系统从启动以来的平均值
```

***实例：***

每隔2秒打印一次每各CPU的状态信息，一共打印3次。

```shell
# mpstat -P ALL 2 3
Linux 3.10.0-862.9.1.el7.x86_64 (new-wlcj)      04/09/2020      _x86_64_        (2 CPU)

01:50:57 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:50:59 PM  all    1.01    0.00    0.50    0.00    0.00    0.00    0.00    0.00    0.00   98.49
01:50:59 PM    0    1.01    0.00    0.50    0.00    0.00    0.00    0.00    0.00    0.00   98.49
01:50:59 PM    1    0.51    0.00    0.51    0.00    0.00    0.00    0.00    0.00    0.00   98.99

01:50:59 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:51:01 PM  all   13.07    0.00    5.03    0.50    0.00    0.00    0.00    0.00    0.00   81.41
01:51:01 PM    0   13.57    0.00    5.03    0.50    0.00    0.00    0.00    0.00    0.00   80.90
01:51:01 PM    1   13.07    0.00    5.03    0.50    0.00    0.00    0.00    0.00    0.00   81.41

01:51:01 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
01:51:03 PM  all   34.77    0.00    3.30    0.00    0.00    0.76    0.00    0.00    0.00   61.17
01:51:03 PM    0   13.20    0.00    5.08    0.00    0.00    1.02    0.00    0.00    0.00   80.71
01:51:03 PM    1   56.06    0.00    1.52    0.00    0.00    0.51    0.00    0.00    0.00   41.92

Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
Average:     all   16.22    0.00    2.94    0.17    0.00    0.25    0.00    0.00    0.00   80.42
Average:       0    9.24    0.00    3.53    0.17    0.00    0.34    0.00    0.00    0.00   86.72
Average:       1   23.19    0.00    2.35    0.17    0.00    0.17    0.00    0.00    0.00   74.12
```

***输出字段说明：***

```shell
%usr	CPU在用户态空间占用百分比。
%sys	CPU在内核空间占用百分比。
%iowait	CPU等待IO读写操作的时间百分比。
%idl	CPU处于空闲转态的时间百分比
```

### 扩展：抓包工具tcpdump


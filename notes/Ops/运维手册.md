# Nginx

## 概述





## 安装

### Yum 安装

官方文档：http://nginx.org/en/linux_packages.html#stable

```shell
cat > /etc/yum.repos.d/nginx.repo <<"EOF"
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
EOF
yum install nginx -y
```



### 配置

#### server配置

```shell
# HTTP redirect
server {
	listen 80;
	server_name download.rmcex.vip;
	location / {
		return 301 https://download.rmcex.vip$request_uri;
	}
}
server {
	listen 443 ssl http2;

	server_name download.rmcex.vip;
	root /site/download.rmcex.vip/public;
	# SSL
	ssl_certificate /etc/nginx/ssl/download.rmcex.vip/fullchain.crt;
	ssl_certificate_key /etc/nginx/ssl/download.rmcex.vip/privkey.key;
	ssl_dhparam  /etc/nginx/ssl/dhparams.pem;
	# logs
	access_log /var/log/nginx/download.rmcex.vip.access.log;
	error_log /var/log/nginx/download.rmcex.vip.error.log warn;
	# index.html fallback
	location / {
		try_files $uri $uri/ /index.html;
	}
	# proxy
	location / {
		proxy_pass http://127.0.0.1:3000;
		proxy_http_version	1.1;
        proxy_cache_bypass	$http_upgrade;

        proxy_set_header Upgrade			$http_upgrade;
        proxy_set_header Connection 		"upgrade";
        proxy_set_header Host				$host;
        proxy_set_header X-Real-IP			$remote_addr;
        proxy_set_header X-Forwarded-For	$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto	$scheme;
        proxy_set_header X-Forwarded-Host	$host;
        proxy_set_header X-Forwarded-Port	$server_port;
	}
    # gzip
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/rss+xml application/atom+xml image/svg+xml;
}
```

#### http配置

```shell
... ...
worker_processes auto;
worker_rlimit_nofile 65535;
events {
	multi_accept on;
	worker_connections 65535;
}

http {
    ... ...
	charset utf-8;
	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	types_hash_max_size 2048;
	client_max_body_size 16M;
	# SSL
	ssl_dhparam /etc/nginx/ssl/dhparam.pem;
	ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;
	ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ... ...
}

## 生成证书
mkdir /etc/nginx/ssl
ssl_dhparam /etc/nginx/ssl/dhparam.pem
openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048
```



## 维护

### nginx 配置示例

#### Gzip 压缩配置：

```shell
http {
.......
    gzip  on;
    gzip_min_length  1k;
    gzip_buffers     4 16k;
    gzip_http_version 1.1;
    gzip_comp_level 9;
    gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json;
    gzip_disable "MSIE [1-6]\.";
    gzip_vary on;
}
```



#### Nginx 代理后端服务配置

***方法一：***加`/`

示例：

```shell
location ^~/user/ {
	proxy_set_header Host $host;
	proxy_set_header X-Real-IP $remote_addr;
	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	proxy_set_header X-NginX-Proxy true;
	proxy_pass http://user/;
}
```

说明：`^~/user/`表示匹配前缀是user的请求，proxy_pass的结尾有`/`， 则会把`/user/*`后面的路径直接拼接到后面，即移除user。

***方法二：***`rewrite`

示例：

```shell
location ^~/user/ {
	proxy_set_header Host $host;
	proxy_set_header X-Real-IP $remote_addr;
	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	proxy_set_header X-NginX-Proxy true;
	rewrite ^/user/(.*)$ /$1 break;
	proxy_pass http://user;
}
```

说明：proxy_pass结尾没有/， rewrite重写了url。







### 报错及处理

#### "413 Request Entity Too Large"

分析：上传文件大小被限制了，nginx默认上传文件的大小限制是1M，修改加大上传文件大小限制即可。

在`http{}`或`server、location`中加入`client_max_body_size XXm`

reload 即可





开启压缩影响：

压缩前：

![1575973366166](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575973366166.png)



#### Nginx 解决跨域问题

参考文档：<https://blog.csdn.net/qq_35720307/article/details/89680726>

[同源策略和跨域解决方案]<https://www.cnblogs.com/rain-chenwei/p/9520240.html>



浏览器的同源策略：同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。



解决方案：

1. **JSONP**

   优点：兼容老版本浏览器

   缺点：不安全，容易造成xss攻击；只能是GET请求

   原理：<script>标签的src属性不受同源策略的限制，跨域请求的接口返回的是一个函数调用。

2. **CORS**（Cross-origin resource sharing）

   优点：支持POST以及所有HTTP请求；安全性相对JSONP更高

   缺点：不兼容老版本浏览器（如IE9以下）；服务端配置稍微复杂。

3. 比较总结：CORS要求浏览器(>IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。



说明：nginx 代理后端允许 CORS跨域配置、CORS设置，后端允许跨域请求。

```shell
	add_header 'Access-Control-Allow-Origin' $http_origin;
	## Access-Control-Allow-Origin，这里使用变量 $http_origin取得当前来源域。实际工作中将$http_origin修改为允许跨域访问的域名。
	add_header 'Access-Control-Allow-Credentials' 'true';
	## Access-Control-Allow-Credentials，为 true 的时候指请求时可带上Cookie，根据实际情况配置。
	add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
	## Access-Control-Allow-Methods，OPTIONS一定要有的，另外一般也就GET和POST，根据实际应用场景添加。
	add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
	## Access-Control-Allow-Headers，这个要注意，里面一定要包含自定义的http头字段。（前端请求接口时，如果在http头里加了自定义的字段，这里配置一定要写上相应的字段，如这里的“web-token”和“app-token”）
	add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';
	## Access-Control-Expose-Headers，可不设置，默认只能获返回头的6个基本字段，要获取其它额外的，先在这设置才能获取它。
	if ($request_method = 'OPTIONS') {
		add_header 'Access-Control-Max-Age' 1728000;
		add_header 'Content-Type' 'text/plain; charset=utf-8';
		add_header 'Content-Length' 0;
		return 204;
	}
```

实例：

```shell
location /xxx-web {
		add_header 'Access-Control-Allow-Origin' $http_origin;
		add_header 'Access-Control-Allow-Credentials' 'true';
		add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
		add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
		add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';
		if ($request_method = 'OPTIONS') {
			add_header 'Access-Control-Max-Age' 1728000;
			add_header 'Content-Type' 'text/plain; charset=utf-8';
			add_header 'Content-Length' 0;
			return 204;
		}
		root   html;
		index  index.html index.htm;
		proxy_pass http://127.0.0.1:8080;
		proxy_set_header Host $host;
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		proxy_set_header X-Forwarded-Proto $scheme;
		proxy_connect_timeout 5;
	}
```









### 安全优化建议

#### 开启访问日志

开启日志有助于发生安全事件后回溯分析整个事件的原因及定位攻击者。

`access_log /var/log/nginx/access.log combined;`

#### 隐藏版本号

`Server_tokens off;`

#### 禁用非必要的请求方法

`trace` 请求用于网络诊断，会暴露信息，只允许 GET、HEAD、POST 请求，其他请求直接返回444状态码 （444是 Nginx 定义的响应状态码，会立即断开连接，没有响应正文，TRACE 请求 Nginx 内置405拒绝）。     

`if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; }`



# PHP



## 维护



### 配合优化



#### php-fpm 超时设置

默认配置：

php-fpm: `request_terminate_timeout = 0`

php.ini: `max_execution_time = 30`

`max_execution_time`：设置脚本被解析器中止之前允许的最大执行时间。

`request_terminate_timeout`：由于某种原因当`max_execution_time`无法终止脚本的时，超过这个时间会把这个php-fpm请求干掉。

注：`max_execution_time`指的是脚本的执行时间；

`request_terminate_timeout`指的是从http请求开始计算，包括等待响应等。

### 文件权限管理

1. php-fpm配置用户跟nignx保持一致

2. 所有文件属主属组跟php-fpm和nginx定义的用户保持一致

3. 目录权限755，文件权限644

   目录：`find /var/www/html/ -type d -exec chmod 755 {} \;`

   文件：`find /var/www/html/ -type f -exec chmod 644 {} \;`

   补充：部分需要执行权限的文件可以设置为755.



### 安全优化建议

#### 控制脚本访问权限

PHP 默认配置允许 PHP 脚本程序访问服务器上的任意文件，为避免 PHP 脚本访问不该访问的文件，从一定程度上限制了 PHP 木马的危害，需设置 PHP 只能访问网站目录或者其他必须可访问的目录。

```shell
## 配置文件php.ini
open_basedir=/var/www/:/var/lib/php/:/tmp/
## 多个目录通过冒号隔开
```

#### 隐藏 PHP 版本信息

攻击者在信息收集时候无法判断程序版本，增加防御系数。

```shell
## 配置文件 php.ini
expose_php =off
```

#### 禁用 PHP 危险函数

Web 木马程序通常利用 PHP 的特殊函数执行系统命令，查询任意目录文件，增加修改删除文件等。PHP 木马程序常使用的函数为： dl, eval, assert, exec, popen, system, passthru, shell_exec 等。

```shell
## 配置文件 php.ini
disable_functions= dl,eval,assert,exec,passthru,popen,proc_open,shell_exec,system,phpinfo,assert
```

#### 开启 magic_quotes_gpc

`magicquotesgpc` 会把引用的数据中包含单引号 `'`和双引号 `"` 以及反斜线 `\` 自动加上反斜线，自动转译符号，确保数据操作的正确运行，`magicquotesgpc` 的设定值将会影响通过 `Get/Post/Cookies` 获得的数据，可以有效的防止 SQL 注入漏洞。

```shell
## 配置文件 php.ini
magicquotesgpc = On*
```

#### 其它参考配置

- 开启 magic_quotes_runtime，对文件或者数据库中取出的数据过滤，能很好的解决二次注入漏洞。
  `magic_quotes_runtime = On`
- 关闭错误信息提示：
  `display_errors = off`
  `display_startup_errors = off`
- 开启错误日志记录，闭 display_errors 后能够把错误信息记录下来，便于查找服务器运行的原因,同时也要设置错误日志存放的目录，建议跟 webserver 的日志放在一起。
  `log_errors = On`
  `error_log = /usr/local/apache2/logs/php_error.log`
- 不允许调用 dl：
  `enable_dl = off`
- 关闭远程文件，允许访问 URL 远程资源使得 PHP 应用程序的漏洞变得更加容易被利用，PHP  脚本若存在远程文件包含漏洞可以让攻击者直接获取网站权限及上传 Web 木马，一般会在 PHP  配置文件中关闭该功能，若需要访问远程服务器建议采用其他方式，如 libcurl 库：
  `allow_url_fopen =  off`
  `allow_url_include = off`
- 开启 http only：
  `session.cookie_httponly = 1`
  `cookie domain`
- 开启 https secure：
  `session.cookie_secure = 1`
- 适当的 PHP redirects：
  `cgi.force_redirect = 0`
- SQL 的安全模式：
  `sql.safe_mode = on`

#### .htaccess 和 .user.ini 文件

.htaccess是伪静态环境配置文件，用于lamp。
.user.ini是lnmp文件，里面放的是你网站的文件夹路径地址。目的是防止跨目录访问和文件跨目录读取.
配置 放在根目录 .user.ini

```shell
cat .user.ini
open_basedir=/www/aaa/:/tmp/:/proc/
```

实例：没加.user.ini 可直接访问根目录的文件

```shell
# 测试代码
cat test.php
<?php
$dir = dirname(__FILE__);
echo " <pre>";
print_r($dir);
$file = scandir('/');
echo " <pre>";
print_r($file);
?>
# 添加之后就读取不到了
```

详细关于`.user.ini`文件说明可参考：https://segmentfault.com/a/1190000011552335?utm_source=tag-newest





# Tomcat







## 维护

### 安全优化

***启动安全模式：***

为了限制脚本的访问权限，防范 webshell 木马，建议启动时增加安全参数启动。

`Tomcat/bin/startup.sh –security`

***删除 Tomcat 默认页面：***

删除`tomcat/webapps/`目录下的所有文件及目录。

`Tomcat/webapps/docs/`
`Tomcat/webapps/examples/`
`Tomcat/webapps/host-manager/`
`Tomcat/webapps/manager/`
`Tomcat/webapps/ROOT/`

删除 Tomcat 的 admin 控制台软件:删除`{Tomcat安装目录}\webapps`下`admin.xml`文件。
删除 Tomcat 的 Manager 控制台软件:删除`{Tomcat安装目录}\webapps`下`manager.xml`文件。              

***删除 jspx 文件解析：***

Tomcat 默认是可以解析 jspx 文件格式的后缀，解析 jspx 给服务器带来了极大的安全风险，若不需要使用 jspx 文件，建议删除对 jspx 的解析。修改 `conf/web.xml` 文件。

`# <url-pattern>*.jspx</url-pattern>	# 注释掉`

***禁止显示错误信息：***

Tomcat 在程序执行失败时会有错误信息提示，可能泄漏服务器的敏感信息，需要关闭错误提示信息。可以通过指定错误页面的方式不将错误信息显示给用户，修改`tomcat/conf/web.xml`,增加如下配置项：

```shell
<error-page>
<error-code>500</error-code>
<location>/500.jsp</location>
</error-page>
```







# Redis

## 概述



## 安装



# MySQL

## 概述



## 安装

### Yum安装

```shell
cd /usr/local/src
wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
rpm -ivh mysql-community-release-el7-5.noarch.rpm
yum repolist enabled | grep "mysql.*-community.*"
yum info mysql-community-server
yum install mysql-community-server -y
systemctl start mysqld
netstat -lntp |grep mysqld
```



## 维护

### SQL

创建数据库并设置UTF8格式

CREATE DATABASE `database` CHARACTER SET utf8 COLLATE utf8_general_ci;

创建用户并授权：

grant all privileges on `DatabaseName`.* to UserName@'%' identified by 'Password';

创建一个超级管理员用户：

```SHELL
grant all on . to testadmin@'%' identified by '123456';
grant all on . to testadmin@'%' with grant option;
```





### 数据库管理

#### 修改密码策略

查看密码策略规则：

```shell
mysql> show VARIABLES like "%password%";
+----------------------------------------+-----------------+
| Variable_name                          | Value           |
+----------------------------------------+-----------------+
| default_password_lifetime              | 0               |
| disconnect_on_expired_password         | ON              |
| log_builtin_as_identified_by_password  | OFF             |
| mysql_native_password_proxy_users      | OFF             |
| old_passwords                          | 0               |
| report_password                        |                 |
| sha256_password_auto_generate_rsa_keys | ON              |
| sha256_password_private_key_path       | private_key.pem |
| sha256_password_proxy_users            | OFF             |
| sha256_password_public_key_path        | public_key.pem  |
| validate_password_check_user_name      | OFF             |
| validate_password_dictionary_file      |                 |
| validate_password_length               | 8               |
| validate_password_mixed_case_count     | 1               |
| validate_password_number_count         | 1               |
| validate_password_policy               | MEDIUM          |
| validate_password_special_char_count   | 1               |
+----------------------------------------+-----------------+
```

密码策略说明：(默认为 MEDIUM)

| Policy      | Tests Performed                                              |
| ----------- | ------------------------------------------------------------ |
| 0 or LOW    | Length                                                       |
| 1 or MEDIUM | Length; numeric, lowercase/uppercase, and special characters |
| 2 or STRONG | medium + dictionary file                                     |

更改密码策略为LOW

`set global validate_password_policy=0;`



### ERROR

`ERROR 1227 (42000) at line 1350: Access denied; you need (at least one of) the SUPER privilege(s) for this operation`

DEFINER指令中定义的用户没有SUPER特权。

CREATE PROCEDURE和CREATE FUNCTION需要CREATE ROUTINE特权。它们可能还需要SUPER特权，具体取决于DEFINER值，

参考：<https://support.plesk.com/hc/en-us/articles/360005033014-Unable-to-import-MySQL-dump-using-Import-Dump-feature-in-Plesk-ERROR-1227-42000-at-line-1421-Access-denied-you-need-at-least-one-of-the-SUPER-privilege-s-for-this-operation>





# SQLite3

## 概述

## 安装

centos7 默认已经安装了SQLite3。

## 维护

### 管理指令

`sqlite3 dbfile.db` （创建）连接数据库。

`.databases` 显示所有数据库。

`.tables` 显示数据库中所有表。

`.schema TableName` 显示表结构，等同MySQL的`show create table TableName ` 。

```shell
## 导出当前数据库的 SQL 语句
> .output /path/to/file.sql
> .dump [TableName]  ## 默认整个库
# 或
sqlite3 dbfile.db .dump > test.sql
## 导入 SQL 语句
> .import /path/to/file.sql
# 或
sqlite3 dbfile.db < /path/to/file.sql
```

`delete from TableName;`  清空表数据







# Docker

## 概述



## 安装

```shell
## 更新yum包
$ sudo yum update -y
## 卸载旧版本
$ sudo yum remove docker docker-common docker-selinux docker-engine
## 安装需要的软件包 （yum -util 提供 yum-config-manager 功能；另外两个是 devicemapper 驱动的依赖）
$ sudo yum install yum-utils device-mapper-persistent-data lvm2 -y
## 设置 Yum 源
$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
## 查看仓库中的所有 docker 版本
$ sudo yum list docker-ce --showduplicates | sort -r
## 安装指定版本  yum install <FQPN>
$ sudo yum install docker-ce-19.03.1
$ sudo yum install docker-ce -y
## 启动并加入开机自启动
$ sudo systemctl start docker
$ sudo systemctl enable docker
## 验证是否安装成功
$ sudo docker version
```



## 实践

### Docker 跟 NodeJs 最佳实践

#### 简单实现

需求：简单的构建一个app应用并且用docker部署。

```shell
FROM node:7.3.0

RUN mkdir -p /usr/src/app
COPY package.json /usr/src/app/
RUN npm install 
COPY . /usr/src/app

EXPOSE 3000

CMD npm start
```

#### 增加PM2

需求：进程守护运行,自动重启应用(或在启动docker时候添加`restart=always` 也可以实现自动重启)

```shell
FROM node:7.3.0

RUN mkdir -p /usr/src/app
COPY package.json /usr/src/app/
RUN npm install 
COPY . /usr/src/app

EXPOSE 3000

CMD ["pm2","start", "pm2.json","--no-daemon"]
```

#### 传递参数

需求：启动的时候要执行多个带变量的命令、这样的话CMD就满足不了了，只能上shell脚本来完成

```shell
## shell 脚本
cat docker_start.sh
#!/bin/sh

NODE_ENV=$1

if [ -z $NODE_ENV ]
then echo "please input NODE_ENV"
exit 1
fi

echo $NODE_ENV

pm2 start pm2.json --env $NODE_ENV --no-daemon

## Dockerfile
FROM node:boron

# Install global pm2 
RUN npm install pm2 -g --registry=https://registry.npm.taobao.org


# Create app directory
RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

# Install app dependencies
COPY package.json /usr/src/app/
RUN npm install --registry=https://registry.npm.taobao.org


# Bundle app source
COPY . /usr/src/app

ENV NODE_ENV dev

RUN ["chmod", "+x", "/usr/src/app/docker_start.sh"]
CMD /bin/bash /usr/src/app/docker_start.sh $NODE_ENV

EXPOSE 3000

# Build image
# docker build -t pm2_test:v1 .

# Run docker
# docker run -e NODE_ENV=staging --name pm2_test -p 3500:3500  -d  pm2_test:v1
```









## docker-compose

### 安装

```shell
sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
docker-compose --version
```

### 指令

docker-compose start|stop|restart|pause|unpause



docker-compose build|down|up|rm|kill



docker-compose logs|ps|top|config|exec











## 维护

### 国内镜像加速

***国内镜像加速地址：***

[docker官网中国区镜像](https://www.docker-cn.com/)
 `--registry-mirror=https://registry.docker-cn.com` 

 [网易163 docker镜像](https://c.163.com/product/service) **未使用,请自行判断**
 `--registry-mirror=http://hub-mirror.c.163.com` 

 [USTC镜像加速](https://lug.ustc.edu.cn/wiki/mirrors/help/docker)
 `--registry-mirror=https://docker.mirrors.ustc.edu.cn` 

 [daocloud镜像](https://www.daocloud.io/) **需注册**
 `--registry-mirror=http://{your_id}.m.daocloud.io` 

 [alicloud](https://jsfun.info/archive/docker在国内使用的加速配置/) **注册后有自己的加速地址**
 `--registry-mirror=https://{your_id}.mirror.aliyuncs.com`

***配置加速地址：***

- Ubuntu14.04、Debian7Wheezy

  对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：

  ```shell
  $ vim /etc/default/docker
  DOCKER_OPTS="--registry-mirror=https://registry.docker-cn.com"
  $ sudo service docker restart
  ```

- Ubuntu16.04+、Debian8+、CentOS7

  对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：

  ```shell
  $ vim /etc/docker/daemon.json
  {"registry-mirrors":["https://reg-mirror.qiniu.com/"]}
  $ sudo systemctl restart docker
  ```

- 检查加速器是否生效

  ```shell
  
  ```

  

### PHP官方容器扩展工具

***容器php中安装扩展的工具：***

- **docker-php-source**

  创建`/usr/src/php`目录，用于存放PHP扩展源码

  `docker-php-source [extract | delete]  创建或初始化 | 删除 /usr/src/php `

- **docker-php-ext-install**

  安装并启动PHP扩展。

  `docker-php-ext-install “源码包目录名”`

  注意点：

  - “源码包“需要放在 /usr/src/php/ext 下
  - 默认情况下，PHP容器没有 /usr/src/php这个目录，需要使用 docker-php-source extract来生成。
  - docker-php-ext-install 安装的扩展在安装完成后，会自动调用docker-php-ext-enable来启动安装的扩展。
  - 卸载扩展，直接删除/usr/local/etc/php/conf.d 对应的配置文件即可。

- **docker-php-ext-enable**

  启用扩展（替代手动配置php.ini）

  查看现有可启动的扩展：

  `ls -la /usr/local/lib/php/extensions/no-debug-non-zts-20160303/`

- **docker-php-ext-configure**

  用于自定义configure



### Docker PHP 扩展安装汇总

#### 官方扩展

`bcmath, calendar, exif, gettext, sockets, dba,mysqli, pcntl, pdo_mysql, shmop, sysvmsg, sysvsem, sysvshm `

安装：

`docker-php-ext-install -j$(nproc) bcmath calendar exif gettext sockets dba mysqli pcntl pdo_mysql shmop sysvmsg sysvsem sysvshm`

#### bz2 扩展

读写 bzip2（.bz2）压缩文件

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libbz2-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) bz2
```

#### enchant 扩展

拼写检查库

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libenchant-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) enchant
```

#### gd 扩展

图像处理

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libfreetype6-dev libjpeg62-turbo-dev libpng-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ && \
docker-php-ext-install -j$(nproc) gd
```

#### gmp 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libgmp-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) gmp
```

#### soap wddx xmlrpc tidy xsl 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libxml2-dev libtidy-dev libxslt1-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) soap wddx xmlrpc tidy xsl
```

#### zip 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libzip-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) zip
```

#### snmp 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libsnmp-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) snmp
```

#### pgsql, pdo_pgsql 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libpq-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) pgsql pdo_pgsql
```

#### pspell 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libpspell-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) pspell
```

#### recode 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends librecode-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) recode
```

#### pdo_firebird 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends firebird-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) pdo_firebird
```

#### pdo_dblib 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends freetds-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-configure pdo_dblib --with-libdir=lib/x86_64-linux-gnu && \
docker-php-ext-install -j$(nproc) pdo_dblib
```

#### ldap 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libldap2-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-configure ldap --with-libdir=lib/x86_64-linux-gnu && \
docker-php-ext-install -j$(nproc) ldap
```

#### imap 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libc-client-dev libkrb5-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-configure imap --with-kerberos --with-imap-ssl && \
docker-php-ext-install -j$(nproc) imap
```

#### interbase 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends firebird-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) interbase
```

####  intl 扩展

```shell
$ apt-get update && \
apt-get install -y --no-install-recommends libicu-dev && \
rm -r /var/lib/apt/lists/* && \
docker-php-ext-install -j$(nproc) intl
```

#### mcrypt 扩展

```shell
$ apt-get update && \ 
apt-get install -y --no-install-recommends libmcrypt-dev && \
rm -r /var/lib/apt/lists/* && \
pecl install mcrypt-1.0.1 && \
docker-php-ext-enable mcrypt
```

####  imagick 扩展

```shell
$ export CFLAGS="$PHP_CFLAGS" CPPFLAGS="$PHP_CPPFLAGS" LDFLAGS="$PHP_LDFLAGS" && \
apt-get update && \
apt-get install -y --no-install-recommends libmagickwand-dev && \
rm -rf /var/lib/apt/lists/* && \
pecl install imagick-3.4.3 && \
docker-php-ext-enable imagick
```

#### memcached 扩展

```shell
$ apt-get update && \ 
apt-get install -y --no-install-recommends zlib1g-dev libmemcached-dev && \
rm -r /var/lib/apt/lists/* && \
pecl install memcached && \
docker-php-ext-enable memcached
```

#### redis 扩展

```SHELL
$ pecl install redis-5.1.1 && docker-php-ext-enable redis
## https://pecl.php.net/package/redis
```

#### opcache 扩展

```shell
$ docker-php-ext-configure opcache --enable-opcache && docker-php-ext-install opcache
```





# Blockchain

## Geth

### 概述



### 部署



### 维护

<https://www.cnblogs.com/elvi/p/10205777.html>

#### curl 查询区块高度

```shell
#使用curl访问geth api查询区块高度
curl -s -X POST -H "Content-Type":application/json \
--data '{"jsonrpc":"2.0", "method":"eth_blockNumber","params":[],"id":67}' \
 localhost:8545 |awk -F'"' '{print $(NF-1)}'

#如上，查询结果为十六进制
#在shell终端查看十进制区块高度
echo $((`curl -s -X POST -H "Content-Type":application/json --data \
 '{"jsonrpc":"2.0", "method":"eth_blockNumber","params":[],"id":67}' \
 localhost:8545 |awk -F'"' '{print $(NF-1)}'`))
```







#### Supervisor 管理以太坊进程





#### geth 监控



## BTC





# Openvpn

## 概述

Openvpn 是一个非常简单易用的开源VPN，可在Windows、Linux/BSD等各大平台下运行，其核心技术包括虚拟网卡和SSL协议。



## 安装

### Yum 安装

#### 安装 epel 源 easy-rsa openvpn

```shell
yum install -y epel-release 
yum update -y
yum install -y openssl lzo pam openssl-devel lzo-devel pam-devel
yum install -y easy-rsa
yum install -y openvpn
```

#### 生成证书

```shell
## 初始化 PKI
cd ~
/usr/share/easy-rsa/3/easyrsa init-pki
## 生成 CA 证书
/usr/share/easy-rsa/3/easyrsa build-ca nopass
## 生成交互秘钥
/usr/share/easy-rsa/3/easyrsa gen-dh
## 生成服务端密钥
/usr/share/easy-rsa/3/easyrsa build-server-full vpn-server nopass
## 生成客户端密钥
/usr/share/easy-rsa/3/easyrsa build-client-full vpn-client-01 nopass
## 多个客户端可生成多个客户端秘钥
/usr/share/easy-rsa/3/easyrsa build-client-full vpn-client-02 nopass
## 生成证书交互列表，如果不需要 crl-verify 则可以跳过
/usr/share/easy-rsa/3/easyrsa gen-crl
## 生成共享密钥，如果不开启 tls-auth 则可以跳过
openvpn --genkey --secret pki/ta.key
## 拷贝所以生成的证书到 /etc/openvpn/ 目录
```

#### 服务端配置

> 详细配置可参考官方文档：https://openvpn.net/community-resources/how-to/

```shell
cp -R /usr/share/easy-rsa/ /etc/openvpn/
cp /usr/share/doc/openvpn-2.4.8/sample/sample-config-files/server.conf /etc/openvpn/server/
cp -r /usr/share/doc/easy-rsa-3.0.6/vars.example /etc/openvpn/easy-rsa/3.0/vars
cat /etc/openvpn/server.conf
port 1194
proto udp
dev tun
ca /etc/openvpn/easy-rsa/3.0/pki/ca.crt
cert /etc/openvpn/easy-rsa/3.0.3/pki/issued/vpnserver.crt
key /etc/openvpn/easy-rsa/3.0.3/pki/private/vpnserver.key
dh /etc/openvpn/easy-rsa/3.0/pki/dh.pem
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt
push "redirect-gateway def1 bypass-dhcp"
push "dhcp-option DNS 114.114.114.114"
push "dhcp-option DNS 8.8.8.8"
keepalive 10 120
tls-auth ta.key 0
cipher AES-256-CBC
comp-lzo
max-clients 100
user openvpn
group openvpn
persist-key
persist-tun
status openvpn-status.log
log-append openvpn.log
verb 3
mute 20


dh dh2048.pem
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt
keepalive 10 120
tls-auth ta.key 0 # This file is secret
cipher AES-256-CBC
persist-key
persist-tun
status openvpn-status.log
verb 3
explicit-exit-notify 1
```

### Openvpn-server配置说明

```shell
;local 10.10.200.30  ## 默认情况下监听本服务器上所有IP
port 1194  ## 默认监控端口，注意防火墙设置

# 使用的网络协议 TCP/UDP
;proto tcp
proto udp

# tap为以太网通道，桥接模式
# tun为路由IP通道，容易控制
dev tap
;dev tun

# 通常只在Windows下设置，配置多个隧道时指定适配器名称，如：MyTap
;dev-node MyTap

# 服务端和客户端都将使用相同的CA证书
# 服务端和客户端指定各自的证书和密钥
# 服务端和客户端的证书必须使用相同的 Common Name
# 可以使用以配置文件开始为根的相对路径，也可以使用绝对路径
ca /etc/openvpn/easy-rsa/3.0/pki/ca.crt
cert /etc/openvpn/easy-rsa/3.0.3/pki/issued/server.crt
key /etc/openvpn/easy-rsa/3.0.3/pki/private/server.key

# 指定迪菲·赫尔曼参数
# 参数生成命令：openssl dhparam -out dh2048.pem 2048
dh dh2048.pem

# 子网网络拓扑
# Windows客户端且版本低于2.0.9才需要设置
;topology subnet

# 为客户端分配IP地址的VPN的网段，不能和双方的内网网段重复
server 10.8.0.0 255.255.255.0

# 客户端和VIP的对应表，当客户端重连时仍然分配原IP
ifconfig-pool-persist ipp.txt

# 仅针对以太网桥接模式
# 首先，将以太网网卡和TAP进行桥接
# 然后，设置桥接接口的IP地址、子网掩码
# 最后，指定用于分配给客户端的子网的IP范围
;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100

# 仅针对使用DHCP代理的以太网桥接模式
# 仅用于客户端，并且该客户端的TAP适配器需要绑定到一个DHCP客户端上
# 首先，将以太网网卡和TAP进行桥接
;server-bridge

# 推送路由信息到客户端，使客户端能够连接到服务器背后的其他私有子网
;push "route 192.168.10.0 255.255.255.0"
;push "route 192.168.20.0 255.255.255.0"

# 为特定的客户端指定IP，或使客户端背后子网也可以连接到VPN
# 举例，首先取消如下注释：
;client-config-dir ccd
;ifconfig-push 10.9.0.1 10.9.0.2
# 然后在ccd目录中添加以 Common Name 命名的文件，其内容是：
;route 192.168.40.128 255.255.255.248

# 为不同群组的客户端启用不同的防火墙访问策略
# 关于learn-address脚本的更多信息请参考官方手册页面
;learn-address ./script

# 使客户端所有的流量都通过VPN传输，请注意服务端的DHCP设置
push "redirect-gateway def1 bypass-dhcp"

# 用OpenVPN的DHCP功能为客户端提供指定的DNS
push "dhcp-option DNS 114.114.114.114"
push "dhcp-option DNS 8.8.8.8"

# 允许客户端之间互相访问
;client-to-client

# 使具有相同 Common Name 的客户端都可以登陆
# 建议每个客户端都有独立的证书和私钥
;duplicate-cn

# 每10秒ping一次，如果120秒没有回应则认为远程连接已关闭
keepalive 10 120

# 服务端和客户端都需要有该密钥的一个拷贝
# 第二个参数在服务器端应该为'0'，在客户端应该为'1'
tls-auth ta.key 0

# 加密算法
cipher AES-256-CBC

# 在VPN连接上启用压缩并推送至客户端
# 仅2.4以上版本
;compress lz4-v2
;push "compress lz4-v2"

# 在VPN连接上启用压缩，服务端和客户端都必须采用相同配置
comp-lzo

# 最大客户端连接数
max-clients 100

# 降低OpenVPN守护进程的权限
user nobody
group nobody

# 保障重启时仍能保留一些状态
persist-key
persist-tun

# 输出短日志,每分钟刷新一次,以显示当前的客户端
status openvpn-status.log

# 记录日志，重启openvpn后覆盖原log文件
;log openvpn.log

# 记录日志，新日志信息追加到文件最后
log-append openvpn.log

# 日志要记录的级别，值越大日志越详细：
# 0 只记录错误信息
# 4 能记录普通的信息
# 5/6 在连接出现问题时能帮助调试
# 9 显示所有信息，包括包头信息等 
verb 3

# 相同信息的记录次数，连续出现20条后不再记录到日志中
mute 20

# 当服务端重启后，使客户端能自动重连
explicit-exit-notify 1
```

### Openvpn-client 配置说明

```shell
# 指定为客户端
client

;dev tap
dev tun

;dev-node MyTap

;proto tcp
proto udp

# 指定服务器(主机名或IP)以及端口号，可设置多个VPN服务器
remote vpnserver 1194
;remote 10.10.200.32 1194

# 设置多个VPN服务器时，采用随机连接模式，否则按先后顺序(非轮询)
;remote-random

# 启用自动重连，适合不稳定的网络环境
resolv-retry infinite

# 客户端默认不需要绑定本机特定的端口号
nobind

;user nobody
;group nobody

persist-key
persist-tun

# 通过HTTP代理来连接VPN服务器
# 连接失败时自动重试
# 指定代理服务器的IP和端口
;http-proxy-retry
;http-proxy [proxy server] [proxy port]

# 适用于无线网络，忽略重复数据包的警告信息
;mute-replay-warnings

ca ca.crt
cert client.crt
key client.key

# 通过检查证书的nsCertType字段是否与服务端相同，默认为server
# 这是预防潜在攻击的一种重要措施
# 可以通过./easyrsa build-key-server 脚本实现
ns-cert-type server

;tls-auth ta.key 1

;cipher AES-256-CBC

comp-lzo

# 可不与服务端相同
verb 3

;mute 20
```

## 维护

### 撤销证书

```shell
## 先删除文件
rm -rf /etc/openvpn/easy-rsa/3.0/pki/reqs/vpnserver.req
rm -rf /etc/openvpn/easy-rsa/3.0/pki/private/vpnserver.key
## 后撤销证书
cd /etc/openvpn/easy-rsa/3.0
./easyrsa revoke server
./easyrsa gen-crl
## 重启 openvpn 即可
```















# JumpServer

## 概述

Jumpserver 是全球首款完全开源的堡垒机，使用 GNU GPL v2.0 开源协议，是符合 4A 机制的运维安全审计系统。

Jumpserver 使用 Python / Django 进行开发，遵循 Web 2.0 规范，配备了业界领先的 Web Terminal 方案，交互界面美观、用户体验好。

Jumpserver 采纳分布式架构，支持多机房跨区域部署，支持横向扩展，无资产数量及并发限制。

***核心功能：***

- 身份验证 Authentication
  - 登录认证
    - 资源统一登录和认证
    - LDAP 认证
    - 支持 OpenID，实现单点登录
  - 多因子认证
    - MFA（Google Authenticator）

- 账号管理 Account
  - 集中账号管理
    - 管理用户管理
    - 系统用户管理
  - 统一密码管理
    - 资产密码托管
    - 自动生成密码
    - 密码自动推送
    - 密码过期设置
  - 批量密码变更(X-PACK)
  - 多云环境的资产纳管(X-PACK)



## 安装

### 安装说明

***组件说明：***

- **Jumpserver：**管理后台, 管理员可以通过 Web 页面进行资产管理、用户管理、资产授权等操作, 用户可以通过 Web 页面进行资产登录, 文件管理等操作。
- **coco：**SSH Server 和 Web Terminal Server 。用户可以使用自己的账户通过 SSH 或者 Web Terminal 访问 SSH 协议和 Telnet 协议资产。
- **Luna：**Web Terminal Server 前端页面, 用户使用 Web Terminal 方式登录所需要的组件。
- **Guacamole：**RDP 协议和 VNC 协议资产组件, 用户可以通过 Web Terminal 来连接 RDP 协议和 VNC 协议资产。

***端口说明：***

| Protocol | Server name | Port       | 配置文件                        |
| -------- | ----------- | ---------- | ------------------------------- |
| TCP      | Jumpserver  | 8080       | jumpserver/config.yml           |
| TCP      | coco        | 2222, 5000 | coco/config.yml                 |
| TCP      | Guacamole   | 8081       | /config/tomcat9/conf/server.xml |
| TCP      | Db          | 3306       |                                 |
| TCP      | Redis       | 6379       |                                 |
| TCP      | Nginx       | 80         |                                 |

***安装环境：***

```shell
sudo yum update -y
## 防火墙配置
$ sudo firewall-cmd --zone=public --add-port=80/tcp --permanent
$ sudo firewall-cmd --zone=public --add-port=2222/tcp --permanent
$ sudo firewall-cmd --reload
## 关闭 Selinux
$ sudo setenforce 0
$ sudo sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config
## 修改字符集，否则可能报 input/output error的问题，因为日志里打印了中文
$ sudo localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8
$ export LC_ALL=zh_CN.UTF-8
$ sudo sh -c 'echo 'LANG="zh_CN.UTF-8"' > /etc/lcale.conf'
```

### 一站式安装

***安装Redis:***

做 cache 和 celery broke

```shell
$ sudo yum -y install redis
$ sudo systemctl enable redis
$ sudo systemctl start redis
```

***安装MariaDB：***

还可支持sqlite3, mysql, postgres等

```shell
$ sudo yum -y install mariadb mariadb-devel mariadb-server MariaDB-shared
$ sudo systemctl enable mariadb
$ sudo systemctl start mariadb
$ DB_PASSWORD=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 24`
$ echo -e "\033[31m 你的数据库密码是 $DB_PASSWORD \033[0m"
  Bef1Rro2s4fcZetuyToRfhyI
$ mysql -uroot -e "create database jumpserver default charset 'utf8'; grant all on jumpserver.* to 'jumpserver'@'127.0.0.1' identified by '$DB_PASSWORD'; flush privileges;"
```

***安装并配置nginx：***

作为代理服务器整合 Jumpserver 与各个组件



### Docker 快速安装





```shell
# 生成随机加密秘钥, 勿外泄
$ if [ "$SECRET_KEY" = "" ]; then SECRET_KEY=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 50`; echo "SECRET_KEY=$SECRET_KEY" >> ~/.bashrc; echo $SECRET_KEY; else echo $SECRET_KEY; fi



$ if [ "$BOOTSTRAP_TOKEN" = "" ]; then BOOTSTRAP_TOKEN=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 16`; echo "BOOTSTRAP_TOKEN=$BOOTSTRAP_TOKEN" >> ~/.bashrc; echo $BOOTSTRAP_TOKEN; else echo $BOOTSTRAP_TOKEN; fi

docker run --name jms_all -d \
    -v /data/jumpserver/media:/opt/jumpserver/data/media \
    -v /data/jumpserver/mysql:/var/lib/mysql \
    -v /data/jumpserver/conf.d:/var/nginx/conf.d
    -p 6680:80 \
    -p 6622:2222 \
    -e SECRET_KEY=YXt4AtOKuz1db4RFB4jH26xxwopc007IHwljozDKgN2bvo15yf \
    -e BOOTSTRAP_TOKEN=soJBEZX3DD0T9c3y \
    jumpserver/jms_all:latest
```



## 维护

### web 使用

#### 批量执行切换身份执行命令

如：远程更新系统时区

`sudo su -c "ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime"`

远程执行多条指令：

```shell
sudo su -c "echo '* soft nofile 655350' >>/etc/security/limits.conf;\
echo '* hard nofile 655350' >>/etc/security/limits.conf;\
echo '* hard nproc 655350' >>/etc/security/limits.conf;\
echo '* soft nproc 655350' >>/etc/security/limits.conf
"
```



# Jenkins

## 概述



## 安装

### Yum 安装

```shell
## 安装 java
yum search java|grep jdk
yum install java-1.8.0-openjdk
java -version

sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
sudo yum install jenkins -y
## 修改配置文件
sed -i 's#JENKINS_PORT="8080"#JENKINS_PORT="8180"#g' /etc/sysconfig/jenkins
sed -i 's#JENKINS_LISTEN_ADDRESS=""#JENKINS_LISTEN_ADDRESS="127.0.0.1"#g' /etc/sysconfig/jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins
## 配置nginx
# 安装 【略】
## 说明在使用别的端口时需要做proxy_redirect跳转
proxy_redirect  https://jenkins.futurebank.cc  https://jenkins.futurebank.cc:8443;
```

### 离线安装插件

1. 手动下载插件HPI包

   下载链接可以通过在线安装失败日志获取，或在 <http://updates.jenkins-ci.org/download/plugins/> 找到对应的插件下载

2. 安装：插件管理 --> 上传插件`hpi`文件 --> 等待安装完成，重启Jenkins

### 用户管理

插件：

- **Role-based Authorization Strategy** 基于角色的权限管理

#### 不同的用户管理不同的项目

1. 系统管理 --> 全局安全配置 --> 选择"Manage and Assign Roles"

   ![1576547897084](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576547897084.png)

2. 新建用户（如：test/develop/product）

   系统管理 --> 管理用户 --> 新建用户

   ![1576548543418](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576548543418.png)

3. 配置权限

   系统管理 --> Manage and Assign Roles

   注：一个用户想要进行操作必须要有两种角色，一种是全局，一种是`Project`

   ![1576548163447](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576548163447.png)

   1）"Manage Roles:"添加全局角色，创建三种角色，分配全局读权限

   ![1576548866625](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576548866625.png)

   2）"Assign Roles:"分配角色，将用户分为3种属性身份，授予全局角色身份

   ![1576549097700](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576549097700.png)

   3）在"Manage Roles" 的 "Project roles"创建项目角色

   ![1576748205319](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576748205319.png)

   4）给用户分配项目权限"Assign Roles"

   ![1576753345052](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576753345052.png)



## 维护

### Gitlab 自动触发构建以及钉钉通知

场景：代码提交到 `gitlab` 上，`gitlab` 分支变动触发 Jenkins 构建，发布到目标服务器上。更新完成后，通过钉钉机器人提供的`webhook`在钉钉群通知，并打印本次提交者以及提交的内容。

#### 配置 GitLab 触发 Jenkins 自动构建

插件：`GitLab` 和 `GitLab Hook`

特别说明：

> 网上有很多教程，都是去 Gitlab 的用户设置里面配置 Access Token，然后再将 Token 配置到 Jenkins 的系统配置中 GitLab 项里面，其实根本就不需要。

1. Jenkins 配置 GitLab 账户来拉取代码。

   ![1576830940337](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576830940337.png)

   ![1576830865404](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576830865404.png)

2. GitLab 通过配置 Jenkins 提供的 Token 触发 Jenkins 构建。

   **Jenkins配置：**

   1）新建一个自由风格的任务

   2）配置 Git 地址

   ![1576832327439](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576832327439.png)

   3）配置触发器

   ![1576833757706](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576833757706.png)

   "高级"选项卡：

   ![1576834048276](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576834048276.png)

   4）添加构建操作

   ![1576834666551](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576834666551.png)

   **GitLab 配置：**















# NFS

## 概述

### 简介

NFS（Network File System）即网络文件系统，它允许网络中的计算机之间通过网络共享资源。将NFS主机分享的目录，挂载到本地客户端当中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，在客户端端看起来，就像访问本地文件一样。

RPC，基于C/S模型。程序可以使用这个协议请求网络中另一台计算机上某程序的服务而不需知道网络细节，甚至可以请求对方的系统调用。

对于Linux而言，文件系统是在内核空间实现的，即文件系统比如ext3、ext4等是在Kernel启动时，以内核模块的身份加载运行的。

### NFS 优缺点

**优点：**

1. 简单易上手。
2. NFS文件系统内数据是在文件系统之上的，即数据是能看得见的。
3. 部署快速，维护简单方便，且可控，满足需求得就是最好的。
4. 可靠，从软件层面上看。数据可靠性高，经久耐用。数据是文件系统之上的
5. 服务非常稳定。

**缺点：**

1. 存在单点故障，如NFSserver宕机，所有客户端都不能访问共享目录。（可考虑HA方案）
2. 在大数据高并发的场合，NFS效率低，性能有限。
3. 客户端认证是基于IP和主机名的，权限要根据ID识别，安全性一般。
4. NFS数据是明文的，NFS本身不对数据完整性作验证。
5. 多台客户机器挂载一个NFS服务器，维护比较麻烦。

### 工作原理

NFS本身的服务并没有提供数据传递的协议，而是通过使用RPC（远程过程调用 Remote Procedure Call）来实现。当NFS启动后，会随机的使用一些端口，NFS就会向RPC去注册这些端口。RPC就会记录下这些端口，RPC会开启111端口。通过client端和sever端端口的连接来进行数据的传输。因此，在启动nfs之前，要确保rpc服务正在运行。

![img](https://hcdn1.luffycity.com/data/linux-book/img/15.png)

当访问程序通过NFS客户端向NFS服务端存取文件时，其请求数据流程大致如下：

1）首先用户访问网站程序，由程序在`NFS Clinet`发出存取NFS文件的请求，这时`NFS Client`的`rpcbind`服务就会通过网络向`NFS Server`的`rpcbind`的111端口发出NFS文件存取功能的询问请求；

2）`NFS Server`的`rpcbind`找到对应的已注册的NFS端口后，通知`NFS Clinet`的`rpcbind`。此时`NFS Client`获取到正确的端口，并与`NFS daemon`联机存取数据。

3）`NFS Client`把数据存取成功后，返回给前端访问程序，告知给用户存取结果，作为网站用户，就完成了一次存取操作。

**NFS 与 RPC 之间的关系：**

NFS的各项功能都需要向RPC服务注册，所以只有RPC服务才能获取到NFS服务的各项功能对应的端口号、PID、NFS在主机所监听的IP等信息，而NFS客户端也只能通过向RPC服务询问才能找到正确的端口。

**启动的服务组件说明：**

```shell
rpc：远程过程调用协议，是实现本地调用远程主机实现系统调用的协议。
portmapper：负责分配rpc server的端口，并在client端请求时，负责响应目的rpc server端口返回给client端，工作在tcp与udp的111端口上。
rpc.mountd：是nfs服务的认证服务的守护进程，client在收到返回的真正端口时，就会去连接mountd，认证取得令牌。
nfsd：nfs的守护进程，负责接收到用户的调用请求后与内核发出请求并得到调用结果响应给用户，工作在tcp和udp的2049端口。
rpc.lockd：文件锁定，避免多个用户同时修改一个文件。
rpc.statd：文件一致性校验，检查修复多个用户同时修改一个文件造成的文件损坏。同lockd需要服务端和客户端同时运行才能生效。
rpc.idmapd：是NFS的一个程序，用来负责远程client端创建文件后的权限问题。
rpc.rquotad：用用于实现磁盘配额，当client端挂载nfs后可以限制磁盘空间的大小。
```

## 安装

nfs 程序包：`nfs-utils`

rpcbind 程序包：`rpcbind`

### 安装 nfs-util 和 rpcbind

```shell
## 客户端服务端都需安装
## 启动服务需要先启动rpcbind然后再启动NFS
yum install nfs-utils rpcbind -y
systemctl start rpcbind
systemctl start nfs
systemctl enable rpcbind
systemctl enable nfs
```

### 创建共享目录

```shell
## 服务端
mkdir -p /mnt/backup
echo '/mnt/backup *(rw,async,no_root_squash,no_subtree_check)' >> /etc/exports
exportfs -a
## 服务端
mkdir /backup
mount -t nfs server_ip:/mnt/backup /backup
echo "echo "server_ip:/mnt/backup /backup nfs rw,tcp,intr 0 1" >> /etc/fstab"
```

### /etc/exports 配置说明

示例：`/export 172.16.1.34(rw,sync,no_root_squash) *(ro)`

```shell
rw|ro：读写|只读 权限； 

sync：（同步）资料同步写入存储器中。 
async：（异步）资料会先暂时存放在内存中，不会直接写入硬盘。 提升写入效率，宕机丢失风险。

no_root_squash：登入到NFS主机的用户如果是ROOT用户，它对该共享目录具有root权限，此参数很不安全，建议不要使用。 
root_squash：如果是root压缩为匿名用户（默认nfsnobody）。
all_squash：所有访问NFSserver共享目录的用户身份重新设定为指定匿名用户。 

anonuid|anongid：指定匿名用户的UID|UID,此ID必须存在于/etc/passwd中。 

insecure：允许从这台机器过来的非授权访问。
```

注：使用匿名用户，客户端和服务端都必须有该用户且UID和GID保持一致。

### /etc/fstab 配置说明

示例：`server_ip:/export  /mnt/export  nfs  rw,tcp,intr  0 1`

```shell
第1列是需要挂载的文件系统或存储设备
第2列是挂载点
第3列指定文件系统或分区的类型
第4列为挂载选项,可参考man mount
   auto: 系统自动挂载，fstab默认就是这个选项
   ro: read-only
   rw: read-write
   defaults: rw, suid, dev, exec, auto, nouser, and async. 
第5列为dump选项，设置是否让备份程序dump备份文件系统，0为忽略，1为备份。
第6列为fsck选项，告诉fsck程序以什么顺序检查文件系统，0为忽略。 
```

## 维护

### 故障排查

客户端&服务端连接异常

```shell
## 服务端自检
showmount -e server_ip
## 客户端检查
showmount -e server_ip
mount|umount  ## 挂载信息科查看/proc/mounts文件
## 平滑重启 nfs
systemctl reload nfs
## 重载所有挂载点
exportfs -a
```

挂载报错异常：

`umount:/mnt:device is busy` 需要退出挂载目录才能执行卸载。

`NFS server`宕机，需要强制卸载，`umount -lf /mnt`

### 优化

**客户端挂载参数优化：**

`mount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,rsize=131071,wsize=131072 10.0.0.7:/data/ /mnt  ## 兼顾安全性能`

**系统内核优化：**

```shell
cat >> /etc/sysctl.conf << EOF
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
EOF
```









# Zabbix

## 概述



## 安装

### Yum 安装

zabbix 4.4 新特性：https://www.zabbix.com/documentation/4.4/manual/introduction/whatsnew440

zabbix4 部署参考文档：<https://www.zabbix.com/download?zabbix=4.0&os_distribution=centos&os_version=7&db=mysql>

***安装 php***

```shell
## yum 安装
yum install -y php php-gd php-mysql php-fpm php-mbstring php-xml
## 编辑 php.ini 文件
sed -i 's#post_max_size = 8M#post_max_size = 16M#g' /etc/php.ini
sed -i 's#max_execution_time = 30#max_execution_time = 300#g' /etc/php.ini
sed -i 's#max_input_time = 60#max_input_time = 300#g' /etc/php.ini
# date.timezone = Asia/Shanghai
systemctl start php-fpm
systemctl enable php-fpm
```

***安装nginx***

```shell
## 安装 略
## 配置
#server {
#   listen 80;
#   listen [::]:80;
#   server_name zabbix.futurebank.cc;
#   location / {
#       return 301 https://zabbix.futurebank.cc$request_uri;
#   }
#}
server {
    listen 8443 ssl http2;
    listen [::]:8443 ssl http2;
    server_name zabbix.futurebank.cc;
    # SSL
    ssl_certificate /etc/letsencrypt/live/zabbix.futurebank.cc/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/zabbix.futurebank.cc/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/zabbix.futurebank.cc/chain.pem;
    ssl_session_cache    shared:SSL:1m;
    ssl_session_timeout  5m;
    ssl_ciphers  HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers  on;

    access_log /var/log/nginx/zabbix.futurebank.cc.access.log;
    error_log    /var/log/nginx/zabbix.futurebank.cc.error.log;

    location / {
        root /usr/share/zabbix;
        index index.php;
    }
    location ~ \.php$ {
        root           /usr/share/zabbix;
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        fastcgi_param SCRIPT_FILENAME /usr/share/zabbix$fastcgi_script_name;
        include        fastcgi_params;
        fastcgi_buffers 8 128k;
        fastcgi_buffer_size 128k;
    }
}
```

***安装MySQL：***

```shell
## 安装 略
grant all privileges on zabbix.* to zabbix@'%' identified by 'Zabbix@123';
FLUSH PRIVILEGES;
```

***安装zabbix：***

```shell
rpm -Uvh https://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-release-4.4-1.el7.noarch.rpm
yum clean all
yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent
## 修改配置文件
vim /etc/zabbix/zabbix_server.conf
#修改内容如下:
DBHost=localhost
DBName=zabbix
DBUser=zabbix
DBPassword=Zabbix@123
## 导入数据
/usr/share/doc/zabbix-server-mysql-xxx/create.sql.gz
## web 默认登录用户密码：admin/zabbix
```



#### Agent 端安装

下载agent 对应版本的rpm包。

下载地址：

`rpm -Uvh https://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-agent-4.4.2-1.el7.x86_64.rpm`

yum install zabbix-agent -y

修改配置文件：

```shell
sed -i 's#ServerActive=127.0.0.1#ServerActive=172.31.215.230#g' /etc/zabbix/zabbix_agentd.conf
sed -i 's#Hostname=Zabbix server#Hostname=Jumpserver#g' /etc/zabbix/zabbix_agentd.conf
sed -i 's#Server=127.0.0.1#Server=172.31.215.230#g' /etc/zabbix/zabbix_agentd.conf
```

补充Ubuntu:

```shell
wget http://repo.zabbix.com/zabbix/4.4/ubuntu/pool/main/z/zabbix-release/zabbix-release_4.4-1%2Bxenial_all.deb
dpkg -i zabbix-release_4.4-1+xenial_all.deb
apt-get update
apt-get install -y zabbix-agent
```









## 优化

### zabbix 页面中文显示异常(如框框)

首先，分析Zabbix自带字体，可以看到经两次链接后，graphfont.ttf实际指向`/usr/share/fonts/dejavu/DejaVuSans.ttf`

```shell
# cat /usr/share/zabbix/include/defines.inc.php |grep -E "*FONT_NAME*"
define('ZBX_GRAPH_FONT_NAME',           'graphfont'); // font file name
define('ZBX_FONT_NAME', 'graphfont');
# ll /usr/share/zabbix/assets/fonts/graphfont.ttf
/usr/share/zabbix/assets/fonts/graphfont.ttf -> /etc/alternatives/zabbix-web-font
# ll /etc/alternatives/zabbix-web-font
/etc/alternatives/zabbix-web-font -> /usr/share/fonts/dejavu/DejaVuSans.ttf
```

从windows系统`C:\Windows\Fonts`拷贝中文字体文件，如：

`simhei.ttf` 黑体常规

`simkai.ttf` 楷体常规

`simfang.ttf` 仿宋常规

重命名为`DejaVuSans.ttf` 替换到对应 zabbix server 上的字体目录。

浏览器刷新即可。

### Zabbix 添加钉钉报警

![1575448237595](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575448237595.png)

群机器人API文档：https://ding-doc.dingtalk.com/doc#/serverapi2/qf2nxq



https://oapi.dingtalk.com/robot/send?access_token=34398bd41850658d45607d4eb2d2247128b4d3eebcff98d73b35d8abd2c2f4e1



```shell
$ grep alertscripts /etc/zabbix/zabbix_server.conf 
# AlertScriptsPath=${datadir}/zabbix/alertscripts
AlertScriptsPath=/usr/lib/zabbix/alertscripts

$ cat /usr/lib/zabbix/alertscripts/dingding.py 
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import urllib3
import json
import sys
http = urllib3.PoolManager()
token  = "https://oapi.dingtalk.com/robot/send?access_token=34398bd41850658d45607d4eb2d2247128b4d3eebcff98d73b35d8abd2c2f4e1"
head = {'Content-Type':'application/json'}
message = sys.argv[1]
text = '>%s' %(message)
data = {
        "msgtype": "markdown",
        "markdown": {
            "title": "监控小钉报告",
            "text": text
        } 
}
encode_data = json.dumps(data).encode('utf-8')
r = http.request(
        'POST',
        token,
        body = encode_data,
        headers = head
)
# chmod +x /usr/lib/zabbix/alertscripts/dingding.py 
```



动作配置：

![1575449661069](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575449661069.png)



![1575449589621](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575449589621.png)

报警消息内容：

```shell
#### 服务器报警：
#### 告警主机：{HOSTNAME1}
#### 告警IP： {HOST.IP}
#### 告警时间：{EVENT.DATE} {EVENT.TIME}
#### 告警等级：{TRIGGER.SEVERITY}
#### 触发名称： {TRIGGER.NAME}
#### 告警项目：{TRIGGER.KEY1}
#### 问题详情：{ITEM.NAME}：{ITEM.VALUE}
#### 当前状态：{TRIGGER.STATUS}：{ITEM.VALUE1}
#### 事件ID：{EVENT.ID}
```

恢复消息内容：

```shell
#### 服务器恢复：
#### 告警主机：{HOSTNAME1}
#### 告警主机IP：{HOST.IP}
#### 告警时间：{EVENT.DATE} {EVENT.TIME}
#### 告警等级：{TRIGGER.SEVERITY}
#### 告警信息：{TRIGGER.NAME}
#### 告警项目：{TRIGGER.KEY1}
#### 问题详情：{ITEM.NAME}:{ITEM.VALUE}
#### 当前状态：{TRIGGER.STATUS}:{ITEM.VALUE1}
#### 事件ID：{EVENT.ID}
#### 事件状态：{EVENT.STATUS}
```









## 维护

### 监控端口

zabbix 端口监控的几个主要 `keys`：

| Keys                                      | 说明                                                        |
| ----------------------------------------- | ----------------------------------------------------------- |
| net.tcp.listen[port]                      | 监控TCP端口是否在LISTEN，0--not,1--yes                      |
| net.tcp.port[<ip>,port]                   | 检查TCP端口是否可以正常连接。0--not,1--yes，IP默认127.0.0.1 |
| net.tcp.service[service,<ip>,<port>]      | 检查服务是否可用，FTP服务可直接使用FTP模板。                |
| net.tcp.service.perf[service,<ip>,<port>] | 监控服务（端口）连接性能。                                  |
| net.udp.listen[port]                      | 监控UDP端口是否监听。                                       |

通过自动发现实现端口监控：

两个脚本：

1. 端口自动发现 python 实现

   ```shelL
   #!/usr/bin/python
   # -*- coding: utf-8 -*-
   # 使用python2 commands模块
   
   import re
   import commands
   import json
   
   DROP_LIST = ['22','25','111']    # 排除端口
   
   def filterList():
       DROP_str = "|".join(DROP_LIST)
       CMD="sudo netstat -pntl | awk '{print $4,$7}'|grep  [0-9] |egrep -vw '%s'" % (DROP_str)
       Result_Str = commands.getoutput(CMD)
       #print (Result_Str)
       tmp_list = Result_Str.split("\n") #每行加入列表
       new_dict = {}
       for line in tmp_list:
          # print (line)
          PORT_REG = re.search(r"(127.0.0.1:|:::|0.0.0.0:)(\d+).+\d+/(\S+)",line)
          if PORT_REG is not None:
              match_line =  (PORT_REG.groups())
              new_dict[ match_line[-1]]  =  match_line[-2]
       return new_dict
   
   if __name__ == "__main__":
       Results = filterList()
   
       #格式化成适合zabbix lld的json数据
       ports = []
       for key  in  Results:
           ports += [{'{#PNAME}':key,'{#PPORT}':Results[key]}]
       print json.dumps({'data':ports},sort_keys=True,indent=4,separators=(',',':'))
   ```

2. zabbix-agent 配置中添加 key

   `UserParameter=discovery.ports,/usr/bin/python /etc/zabbix/scripts/zabbix_ports_discovery.py`

3. Web端添加自动发现

   添加模板：

   ![1575863906535](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575863906535.png)

   在相应模板添加自动发现规则：

   ![1575864086127](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575864086127.png)

   添加监控项原型：

   ![1575864212524](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1575864212524.png)

   添加触发器：




### Web 监控

1）Web 场景

选择一台测试主机，如：zabbix server -->在"Web 场景"添加

![1576132257236](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576132257236.png)

步骤：

![1576132306480](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576132306480.png)



![1576132437843](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576132437843.png)

2）触发器

![1576132568514](C:\Users\jason\AppData\Roaming\Typora\typora-user-images\1576132568514.png)



# GitLab



## 维护管理

### Webhooks 自动更新

**Webhooks 的实现原理：**

webhooks允许指定一个URL，用于触发push或其他事件时进行自定义操作。

例如，当开发者push代码到GitLab服务器，会触发push事件，GitLab会发送一个POST请求连带数据给webhooks指定的URL，该URL可以是前端web的php程序或Python程序等。这样，每当GitLab有push事件，就能在前端web服务器上执行一个脚本程序。

**Webhooks 实现步骤：**

- 在前端web服务器上安装Git客户端，用于拉取远程仓库 git pull
- 创建并添加公钥，以便免密码拉取远程仓库
- 创建脚本程序，并配置webhooks

















# Scripts



## 实例

### go app 服务管理脚本

```shell
#!/bin/bash

AppDir=/opt/apps/webapi # App目录
App=${AppDir}/main  # App绝对路径
StartCMD="${App} -addr :8088"

function app_start() {
    echo "Starting ${App}......"
    nohup ${StartCMD} >>${AppDir}/log.out 2>&1 &
    echo "Start Finished."
}

function app_stop(){
    echo "Stopping ${App}......"
    kill -9 $(ps -ef |grep "${StartCMD}" |grep -v grep |awk '{print $2}')
    echo "Stop Finished."
}

case $1 in
"start")
app_start
;;
"stop")
app_stop
;;
"restart")
app_stop
sleep 2
app_start
;;
*)
echo "Usage:sh $0 start|stop|restart"
;;
esac

```

### 跳板机部署（nginx+jumpserver+jenkins）

```shell

## 免密认证



## 安装nginx






```





# Network

## Iptables

centos7系统使用firewalld服务替代了iptables服务，但是依然可以使用iptables来管理内核的netfilter. 事实上firewall rules 防火墙的规则 其实就是保存在 /etc/sysconfig/iptables

### IP 黑名单屏蔽指定IP

`iptables -I INPUT -s X.X.X.X -j DROP`

- 封单个IP：`iptables -I INPUT -s x.x.x.x -j DROP`
- 封IP段：`iptables -I INPUT -s x.x.x.x/16 -j DROP `
- 取消屏蔽：`iptables -D INPUT -s x.x.x.x -j DROP`

`iptables -I` 和 `iptables -A` 区别：

​	防火墙由上往下匹配，-A 会将后执行的策略添加到已有策略后，而-I 则会插入到已有策略的前(既成为第一条策略)。

查看已添加的iptables规则：`iptables -L -n`

​	-n ：只显示IP地址和端口号，不将ip

​	`iptables -n -L INPUT --line-number` 按序号列出规则

​	`iptables -D INPUT 1` 删除指定序号规则

## Tcpdump

tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，这个库在几乎在所有的 Linux/Unix 中都有。

### 基本语法和使用方法

`tcpdump`的常用参数：`tcpdump -i eth0 -nn -s0 -v port 80`

- `-i`：选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 vlan 或其他特殊接口。
- `-nn`：单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。
- `-s0`：tcpdump 默认截取前 96 字节的内容，`-s`指定要截取的报文字节数，0表示全部。
- `-v`：显示更详细的信息。
- `port 80`：指定端口，这里表示抓取 80 端口上的流量。

补充其它常用参数：

- **-p** : 不让网络接口进入混杂模式。默认情况下使用 tcpdump 抓包时，会让网络接口进入混杂模式。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。如果设备接入的交换机开启了混杂模式，使用 -p 选项可以有效地过滤噪声。

- **-e** : 显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息。

  `tcpdump -n -e -c 5 not ip6`

**显示 ASCII 字符串**

` tcpdump -A -s0 port 80`

-A 表示使用 ASCII 字符串打印报文的全部数据，这样可以使读取更加简单，方便使用 grep 等工具解析输出内容。-X 表示同时使用十六进制和 ASCII 字符串打印报文的全部数据。这两个参数不能一起使用。

**抓取特定协议的数据**

`tcpdump -i eth0 udp`

UDP:  `udp 或 protocol 17`

TCP:  `tcp 或 protocol 6`

**抓取特定主机的数据**

使用过滤器 host 可以抓取特定目的地和源 IP 地址的流量：

`tcpdump -i eth0 host 1.1.1.1`

使用 src 或 dst 只抓取源或目的地：

`tcpdump -i eth0 dst 1.1.1.1`

**将抓取的数据写入文件**

-w 选项用来把数据报文输出到文件：

`tcpdump -i eth0 -s0 -w test.pcap`

**行缓冲模式**

如果想实时将抓取到的数据通过管道传递给其他工具来处理，需要使用 -l 选项来开启行缓冲模式（或使用 -c 选项来开启数据包缓冲模式）。使用 -l 选项可以将输出通过立即发送给其他命令，其他命令会立即响应。

`tcpdump -i eth0 -s0 -l port 80 | grep 'Server:'`

**组合过滤器**

过滤的真正强大之处在于你可以随意组合它们，而连接它们的逻辑就是常用的 `与 AND &&` 、 `或 OR ||` 和 `非 not !`。

### 过滤器

**Host 过滤器**

Host 过滤器用来过滤某个主机的数据报文。

`tcpdump host 1.2.3.4`

**Network 过滤器**

Network 过滤器用来过滤某个网段的数据，使用的是 CIDR 模式。

`cpdump net 192.168.1`

**Proto 过滤器**

Proto 过滤器用来过滤某个协议的数据，关键字为 proto，可省略。proto 后面可以跟上协议号或协议名称，支持 icmp, igmp, igrp, pim, ah, esp, carp, vrrp, udp和 tcp。因为通常的协议名称是保留字段，所以在于 proto 指令一起使用时，必须根据 shell 类型使用一个或两个反斜杠（/）来转义。Linux 中的 shell 需要使用两个反斜杠来转义，MacOS 只需要一个。

`tcpdump -n proto \\icmp 或 tcpdump -n icmp `

**Port 过滤器**

Port 过滤器用来过滤通过某个端口的数据报文，关键字为 port。

`tcpdump port 389`



### 理解 tcpdump 的输出

```shell
21:27:06.995846 IP (tos 0x0, ttl 64, id 45646, offset 0, flags [DF], proto TCP (6), length 64)
    192.168.1.106.56166 > 124.192.132.54.80: Flags [S], cksum 0xa730 (correct), seq 992042666, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 663433143 ecr 0,sackOK,eol], length 0

21:27:07.030487 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 44)
    124.192.132.54.80 > 192.168.1.106.56166: Flags [S.], cksum 0xedc0 (correct), seq 2147006684, ack 992042667, win 14600, options [mss 1440], length 0

21:27:07.030527 IP (tos 0x0, ttl 64, id 59119, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.1.106.56166 > 124.192.132.54.80: Flags [.], cksum 0x3e72 (correct), ack 2147006685, win 65535, length 0
```



### 示例

#### 抓取 HTTP 用户代理

从 HTTP 请求头中提取 HTTP 用户代理：

`tcpdump -nn -A -s1500 -l | grep "User-Agent:"`

通过 egrep 可以同时提取用户代理和主机名（或其他头文件）：

`tcpdump -nn -A -s1500 -l | egrep -i 'User-Agent:|Host:'`

#### 只抓取 HTTP GET 和 POST 流量

抓取 HTTP GET 流量：

`tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420'`

抓取 HTTP POST 请求流量：

`tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354'`

注：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST 请求会被分割为多个 TCP 数据包。

说明：上述两个表达式中的十六进制将会与 GET 和 POST 请求的 ASCII 字符串匹配。

**提取 HTTP 请求的 URL**

提取 HTTP 请求的主机名和路径：

```shell
tcpdump -s 0 -v -n -l | egrep -i "POST /|GET /|Host:"

tcpdump: listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes
    POST /wp-login.php HTTP/1.1
    Host: dev.example.com
    GET /wp-login.php HTTP/1.1
    Host: dev.example.com
    GET /favicon.ico HTTP/1.1
    Host: dev.example.com
    GET / HTTP/1.1
    Host: dev.example.com
```

#### 提取 HTTP POST 请求中的密码

从 HTTP POST 请求中提取密码和主机名：

```shell
tcpdump -s 0 -A -n -l | egrep -i "POST /|pwd=|passwd=|password=|Host:"

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes
11:25:54.799014 IP 10.10.1.30.39224 > 10.10.1.125.80: Flags [P.], seq 1458768667:1458770008, ack 2440130792, win 704, options [nop,nop,TS val 461552632 ecr 208900561], length 1341: HTTP: POST /wp-login.php HTTP/1.1
.....s..POST /wp-login.php HTTP/1.1
Host: dev.example.com
.....s..log=admin&pwd=notmypassword&wp-submit=Log+In&redirect_to=http%3A%2F%2Fdev.example.com%2Fwp-admin%2F&testcookie=1
```

#### 提取 Cookies

提取 Set-Cookie（服务端的 Cookie）和 Cookie（客户端的 Cookie）：

```shell
tcpdump -nn -A -s0 -l | egrep -i 'Set-Cookie|Host:|Cookie:'

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes
Host: dev.example.com
Cookie: wordpress_86be02xxxxxxxxxxxxxxxxxxxc43=admin%7C152xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxfb3e15c744fdd6; _ga=GA1.2.21343434343421934; _gid=GA1.2.927343434349426; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_86be654654645645645654645653fc43=admin%7C15275102testtesttesttestab7a61e; wp-settings-time-1=1527337439
```

#### 抓取 ICMP 数据包

```shell
tcpdump -n icmp

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes
11:34:21.590380 IP 10.10.1.217 > 10.10.1.30: ICMP echo request, id 27948, seq 1, length 64
11:34:21.590434 IP 10.10.1.30 > 10.10.1.217: ICMP echo reply, id 27948, seq 1, length 64
11:34:27.680307 IP 10.10.1.159 > 10.10.1.1: ICMP 10.10.1.189 udp port 59619 unreachable, length 115
```

补充：抓取非 ECHO/REPLY 类型的 ICMP 数据包

```shell
tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply'

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes
11:37:04.041037 IP 10.10.1.189 > 10.10.1.20: ICMP 10.10.1.189 udp port 36078 unreachable, length 156
```

#### 抓取 SMTP/POP3 协议的邮件

可以提取电子邮件的正文和其他数据。例如，只提取电子邮件的收件人：

```shell
tcpdump -nn -l port 25 | grep -i 'MAIL FROM\|RCPT TO'
```

#### 抓取 SNMP 服务的查询和响应

通过 SNMP 服务，渗透测试人员可以获取大量的设备和系统信息。在这些信息中，系统信息最为关键，如操作系统版本、内核版本等。使用 SNMP 协议快速扫描程序 onesixtyone，可以看到目标系统的信息：

```shell
$ onesixtyone 10.10.1.10 public

Scanning 1 hosts, 1 communities
10.10.1.10 [public] Linux test33 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64复制代码


# 可以通过 tcpdump 抓取 GetRequest 和 GetResponse：
$ tcpdump -n -s0  port 161 and udp

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes
23:39:13.725522 IP 10.10.1.159.36826 > 10.10.1.20.161:  GetRequest(28)  .1.3.6.1.2.1.1.1.0
23:39:13.728789 IP 10.10.1.20.161 > 10.10.1.159.36826:  GetResponse(109)  .1.3.6.1.2.1.1.1.0="Linux testmachine 4.15.0-20-generic #21-Ubuntu SMP Tue Apr 24 06:16:15 UTC 2018 x86_64"
```

#### 切割 pcap 文件

当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每 3600 秒创建一个新文件 capture-(hour).pcap，每个文件大小不超过 200*1000000 字节：

`tcpdump  -w /tmp/capture-%H.pcap -G 3600 -C 200`

这些文件的命名为 capture-{1-24}.pcap，24 小时之后，之前的文件就会被覆盖。

#### 过滤 Nmap NSE 脚本测试结果

本例中 Nmap NSE 测试脚本 http-enum.nse 用来检测 HTTP 服务的合法 URL。

```shell
在执行脚本测试的主机上：

$ nmap -p 80 --script=http-enum.nse targetip

在目标主机上：

$ tcpdump -nn port 80 | grep "GET /"

GET /w3perl/ HTTP/1.1
GET /w-agora/ HTTP/1.1
GET /way-board/ HTTP/1.1
GET /web800fo/ HTTP/1.1
GET /webaccess/ HTTP/1.1
GET /webadmin/ HTTP/1.1
GET /webAdmin/ HTTP/1.1复制代码
```

#### 抓取 DNS 请求和响应

向 Google 公共 DNS 发起的出站 DNS 请求和 A 记录响应可以通过 tcpdump 抓取到：

```shell
tcpdump -i wlp58s0 -s0 port 53

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlp58s0, link-type EN10MB (Ethernet), capture size 262144 bytes
14:19:06.879799 IP test.53852 > google-public-dns-a.google.com.domain: 26977+ [1au] A? play.google.com. (44)
14:19:07.022618 IP google-public-dns-a.google.com.domain > test.53852: 26977 1/0/1 A 216.58.203.110 (60)
```

#### 抓取 HTTP 有效数据包

抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN / FIN / ACK）：

`tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'`

#### 找出发包最多的 IP

找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的 IP，可以使用下面的命令：

```shell
tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d '.' | sort | uniq -c | sort -nr | head -n 20

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on enp7s0, link-type EN10MB (Ethernet), capture size 262144 bytes
200 packets captured
261 packets received by filter
0 packets dropped by kernel
    108 IP 10.10.211.181
     91 IP 10.10.1.30
      1 IP 10.10.1.50
```

#### 抓取用户名和密码

本例将重点放在标准纯文本协议上，过滤出于用户名和密码相关的报文：

```shell
tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user '
```

#### 抓取 DHCP 报文

抓取 DHCP 服务的请求和响应报文，67 为 DHCP 端口，68 为客户机端口。

`tcpdump -v -n port 67 or 68`





## 网络排查

### mtr 公网探测工具

```shell
# mtr -n 47.90.89.194
      quit                   Packets               Pings
 Host                  Loss%   Snt   Last   Avg  Best  Wrst StDev
 1. 192.168.1.1         0.0%   132    1.0   1.6   0.5  22.3   2.5
 2. 100.64.0.1          0.0%   132    3.9   5.9   2.1  16.5   2.1
 3. 113.106.38.242      0.0%   132   17.4   9.7   2.2 112.5  14.2
 4. 183.56.65.14        0.0%   132    8.9   8.7   6.0  29.0   2.3
 5. 59.43.80.17         0.0%   132    6.1   9.1   5.8  43.5   3.9
 6. 59.43.18.246        0.0%   132    6.1  11.5   5.3  99.4  14.9
 7. 59.43.130.126      43.9%   132   14.8   9.2   6.6  35.8   4.4
 8. 59.43.187.90       14.5%   132   16.1  18.7   7.8 122.1  13.2
 9. 59.43.183.106       0.8%   132   24.5  23.6  10.1 130.6  16.9
10. 59.43.248.146       0.0%   132   17.7  13.7  11.0  38.7   4.1
11. 203.100.49.214      4.6%   131   11.8  19.1  11.2  54.9   6.8
12. 116.251.87.1        2.3%   131   17.9  26.0  11.3  73.1  11.6
13. 11.16.2.189         2.3%   131   24.8  36.3  15.1 107.0  16.4
14. 11.52.240.21        3.8%   131   17.7  28.2  10.9  48.8   8.8
15. 47.90.89.194        0.0%   131   12.5  13.4  11.8  31.1   2.6
#### 说明 ####
1.到47.90.89.194需要十四跳
2.Packet：
  Loss%(丢包百分比)，Snt(已发送的包数),Last(最后一个发包的延时)
3.Pings:
  Avg(平均延时)，Best(最低延时)，Wrst(最差延时)，StDev(方差，稳定性指标)
```

补充：MTR ，默认使用ICMP协议做mtr，但是因为ICMP报文优先级比较低，有可能会被一部分路由器丢弃，不能探测到真实情况，所以有时还需要使用TCP做mtr。

`mtr -rc www.baidu.com -n --tcp -P 443`

一般在某个IP上，出现严重丢包的点为路劲的Block的点。

**安装：**

centos7:`yum  install mtr -y`

### 实时流量 nethogs



# WAF

## ModSecurity

### 概述

　ModSecurity是一个开源的跨平台Web应用程序防火墙（WAF）引擎，用于Apache，IIS和Nginx，由Trustwave的SpiderLabs开发。作为WAF产品，ModSecurity专门关注HTTP流量，当发出HTTP请求时，ModSecurity检查请求的所有部分，如果请求是恶意的，它会被阻止和记录。

注：据说产品是开源免费，但规则库是收费的。

***优势：***

- 开源免费
- 完美兼容nginx，是nginx官方推荐的WAF
- 支持OWASP规则
- 3.0版本比老版本更新更快，更加稳定，并且得到了nginx、Inc和Trustwave等团队的积极支持。

***劣势：***

不支持检查响应体的规则，如果配置中包含这些规则，则会被忽略，nginx的的sub_filter指令可以用来检查状语从句：重写响应数据，OWASP中相关规则是95X。

不支持OWASP核心规则集DDoS规则REQUEST-912-DOS- PROTECTION.conf,nginx本身支持配置DDoS限制

不支持在审计日志中包含请求和响应主体

***功能：***

SQL Injection (SQLi)：阻止SQL注入
Cross Site Scripting (XSS)：阻止跨站脚本攻击
Local File Inclusion (LFI)：阻止利用本地文件包含漏洞进行攻击
Remote File Inclusione(RFI)：阻止利用远程文件包含漏洞进行攻击
Remote Code Execution (RCE)：阻止利用远程命令执行漏洞进行攻击
PHP Code Injectiod：阻止PHP代码注入
HTTP Protocol Violations：阻止违反HTTP协议的恶意访问
HTTPoxy：阻止利用远程代理感染漏洞进行攻击
Shellshock：阻止利用Shellshock漏洞进行攻击
Session Fixation：阻止利用Session会话ID不变的漏洞进行攻击
Scanner Detection：阻止黑客扫描网站
Metadata/Error Leakages：阻止源代码/错误信息泄露
Project Honey Pot Blacklist：蜜罐项目黑名单
GeoIP Country Blocking：根据判断IP地址归属地来进行IP阻断

### 安装部署

```shell
yum update -y
## RHEL/CentOS安装最新版本的Nginx
yum install yum-utils -y
cat > /etc/yum.repos.d/nginx.repo <<"EOF"
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
EOF
yum install nginx -y
## 安装依赖
yum install epel-release -y
yum install gcc-c++ flex bison yajl yajl-devel curl-devel curl GeoIP-devel doxygen zlib-devel pcre pcre-devel libxml2 libxml2-devel autoconf automake lmdb-devel ssdeep-devel ssdeep-libs lua-devel libmaxminddb-devel git apt-utils autoconf automake build-essential git libcurl4-openssl-dev libgeoip-dev liblmdb-dev ibpcre++-dev libtool libxml2-dev libyajl-dev pkgconf wget zlib1g-dev -y
## 编译 ModSecurity v3

```



## OpenResty





# Shell

## /bin/bash

### 环境变量

Linux 环境变量用户环境变量通常被存储在下面的文件中：

`~/.profile`

`~/.bash_profile` 或者 `~./bash_login`

`~/.bashrc`

系统环境变量：

`/etc/environment`

`/etc/profile`

`/etc/bashrc`

环境变量的优先级：

1. `/etc/profile`：

   在登录时,操作系统定制用户环境时使用的第一个文件,此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件自动被执行。

2. `/etc/environment`：

   在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。

3. `~/.bash_profile`：

   

## Linux 权限控制

### i 属性文件

i 属性文件不可被修改。

背景：**Linux中的一些病毒,经常会修改,文件的权限为特殊权限,就连root用户也动不了这个 **

使用root用户也提示错误信息：`changing permissions of 'xxx': Operation not permitted；`

命令：

chattr 更改文件属性

​	**添加 i 属性**：`chattr +i /etc/sysctl.conf`

​	**去除 i 属性**：`chattr -i /etc/sysctl.conf`

lsattr 查看文件属性 `lsattr /etc/sysctl.conf `

### Linux ACL 访问控制权限

设置权限：`setfacl`

查看权限：`getfacl`

- 用法：`setfacl [-bkndRLP] { -m|-M|-x|-X ... } file ...`

  -m：修改指定文件或目录当前的ACL

  -M：





## 日志限制

### message报messages lost due to rate-limiting

参考文章：<https://www.rootusers.com/how-to-change-log-rate-limiting-in-linux/>





# Ubuntu

## Ubuntu 18

### 配置静态IP

```shell
mv /etc/netplan/{50-cloud-init.yaml,50-cloud-init.yaml.backup}
# cat << EOF > /etc/netplan/50-cloud-init.yaml
network:
    ethernets:
        enp1s0:
            dhcp4: no
            addresses: [192.168.0.101/24]
            optional: true
            gateway4: 192.168.0.1
            nameservers:
                    addresses: [192.168.1.1,114.114.114.114]
        enp2s0:
            dhcp4: true
    version: 2
EOF
# 应用配置
netplan apply
```





# windows

## windows10

### 系统激活

> 参考：https://baijiahao.baidu.com/s?id=1620924952478049508&wfr=spider&for=pc

***概述：***

现在市面上大致有两种主流激活方法，一种是通过激活码来激活，另外一种是通过激活工具来激活。但是激活工具有个弊端就是激活时间只有180天。

***激活实操(教育版)：***

1. 管理员身份运行`CMD`
2. 卸载旧密钥：`slmgr.vbs /upk`
3. 安装新密钥：`slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX`
4. 设置密钥管理服务计算机名：`slmgr /skms zh.us.to`
5. 激活产品：`slmgr /ato`
6. 等待激活成功，右键"我的电脑"-->"属性"，查看是否激活成功。

***补充win10系统其它版本密钥：***

| 版本         | 密钥                                                         |
| ------------ | ------------------------------------------------------------ |
| 企业版       | XGVPP-NMH47-7TTHJ-W3FW7-8HV2C<br />PBHCJ-Q2NYD-2PX34-T2TD6-233PK |
| 专业版       | NKJFK-GPHP7-G8C3J-P6JXR-HQRJR                                |
| 教育版       | W269N-WFGWX-YVC9B-4J6C9-T83GX（实测可用）<br />YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY |
| 专业版N      | 2B87N-8KFHP-DKV6R-Y2C8J-PKCKT                                |
| 企业版N      | WGGHN-J84D6-QYCPR-T7PJ7-X766F                                |
| 教育版N      | 84NGF-MHBT6-FXBX8-QWJK7-DRR8H                                |
| 企业版S      | FWN7H-PF93Q-4GGP8-M8RF3-MDWWW                                |
| Enterprise   | NPPR9-FWDCX-D2C8J-H872K-2YT43<br />CKFK9-QNGF2-D34FM-99QX3-8XC4K |
| Enterprise N | DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4                                |
| Pro          | TPYNC-4J6KF-4B4GP-2HD89-7XMP6<br />2BXNW-6CGWX-9BXPV-YJ996-GMT6T<br />NRTT2-86GJM-T969G-8BCBH-BDWXG<br/>XC88X-9N9QX-CDRVP-4XV22-RVV26<br/>TNM78-FJKXR-P26YV-GP8MB-JK8XG<br/>TR8NX-K7KPD-YTRW3-XTHKX-KQBP6<br/>VK7JG-NPHTM-C97JM-9MPGT-3V66T<br/>NPPR9-FWDCX-D2C8J-H872K-2YT43<br/>W269N-WFGWX-YVC9B-4J6C9-T83GX<br/>NYW94-47Q7H-7X9TT-W7TXD-JTYPM<br/>NJ4MX-VQQ7Q-FP3DB-VDGHX-7XM87<br/>MH37W-N47XK-V7XM9-C7227-GCQG9 |









# 其它杂记

## 



## 远程文件传输

### nc 

示例①.文件拷贝

A：监听端口`nc -l 8089 > filename`

B：传输文件 `nc A_IP 8089 < filename`

示例②.拷贝目录

A：`nc -l 8089 | tar xfvz -`

B：`tar zcvf - * | nc A_IP 8089`

## 文本处理

### 使用ag替代grep

```text
yum install epel-release -y
yum install the_silver_searcher -y
```

用法类似grep，默认已显示行号。



## git

### git usage



查看本地仓库远程地址：`git remote -v`

查看远端所有分支：`git branch -r`



`error: Your local changes to the following files would be overwritten by merge:`

本地文件与远端仓库冲突。

去到指定需强制覆盖目录

`git checkout .`

`git pull`



git reset 本地版本回滚控制（在做代码更新慎用，会覆盖做了忽略的文件，比如：配置文件）

`git reset --hard 96ddfe5`  指定版本回滚

`git reset --hard HEAD~1` 回滚到上一版本



`git rm --cached application/database.php` 指定文件脱离版本控制

`git rm --cached -r public/web` 指定目录脱离版本控制



git rm --cached public/web



解决1.强制覆盖掉本地

#### Linux记住git账号密码

1. 让git读取账密文件 `git config --global credential.helper store`
2. 执行 `git clone` 输入账号密码，



### 错误异常

#### git pull error - fatal: repository 'http://xxx.git/' not found

分析：造成的可能原因①.系统保留其它无权限账号。

```shell
# git config -l
...
credential.helper=store  ## 这里表示使用了凭证存储，
...
## 凭证存储设置
git config --global credential.helper store --file ~/.my-credentials ## 默认~/.git-credentials
## 找到该文件修改里面的用户信息即可。
```

## Firewalld

### 概述



### 使用实例

#### 端口控制

可以通过两种方式控制端口的开放，一种是指定端口号另一种是指定服务名。

```shell
firewall-cmd --add-service=mysql 	# 开放mysql端口
firewall-cmd --remove-service=http  # 阻止http端口
firewall-cmd --list-services 		# 查看开放的服务
firewall-cmd --add-port=3306/tcp 	# 开放通过tcp访问3306
firewall-cmd --remove-port=80tcp 	# 阻止通过tcp访问3306
firewall-cmd --list-ports 			# 查看开放的端口
```

#### 端口转发与 IP 伪装

端口转发可以将指定地址访问指定的端口时，将流量转发至指定地址的指定端口。转发的目的如果不指定 ip 的话就默认为本机，如果指定了 ip 却没指定端口，则默认使用来源端口。

注：端口转发需开启 IP 伪装

```shell
## IP 伪装
firewall-cmd --query-masquerade # 检查是否允许伪装IP
firewall-cmd --add-masquerade # 允许防火墙伪装IP
firewall-cmd --remove-masquerade# 禁止防火墙伪装IP
```

实例：

```shell
firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 # 将80端口的流量转发至8080
firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1 # 将80端口的流量转发至192.168.0.1
firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口
```

指定IP指定端口：

```shell
firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="120.79.5.18" port protocol="tcp" port="8565" accept"
firewall-cmd --reload
```









## SSL

### 证书申请

#### certbot

Certbot 是一个简单易用的 SSL 证书部署工具，由 EFF 开发，前身即 Let’s Encrypt 官方（Python）客户端。简单来说，certbot 就是一个简化 Let’s Encrypt 部署，和管理 Let’s Encrypt 证书的工具。certbot的开源项目在GitHub上，https://github.com/certbot/certbot

```shell
wget https://dl.eff.org/certbot-auto
chmod a+x certbot-auto
./certbot-auto certonly --standalone --email 邮箱地址 -d 域名1 -d 域名2 ...
## 查看生成的证书
tree /etc/letsencrypt/live/
## 注：Let’s Encrypt 生成的免费证书有效期为3个月
## 证书续签
./certbot-auto renew
```



#### 泛域名证书

```shell
wget https://dl.eff.org/certbot-auto
chmod a+x certbot-auto
./certbot-auto certonly --server https://acme-v02.api.letsencrypt.org/directory --manual --preferred-challenges dns -d *.futurebank.cc
## 在域名管理商设置DNS TXT 记录 ， 再dig查看是否生效
dig txt _acme-challenge.futurebank.cc
```









## Logs

### Logrotate 日志切割

　logrotate软件是一个日志管理工具，用于非分隔日志，删除旧的日志文件，并创建新的日志文件，起到“转储作用”，可以为系统节省磁盘空间。一般centos系统已经自带安装好了。

​    logrotate是基于crontab运行的，其脚本是/etc/cron.daily/logtotate，日志轮转是系统自发完成的，实际运行时，logrotate会调用配置文件/etc/logrotate.conf。可以在/etc/logrotate.d目录里放置自定义好的配置文件，用来覆盖logrotate.conf的缺省值。



**logrotate 切割日志的两种机制：**

1）默认方式：重命名原日志文件，创建新的日志文件。

说明：

1. 重命名只会修改目录文件的内容，而进程操作文件靠的是inode编号，所以并不影响程序继续输出日志。
2. 创建新的日志文件，文件名和原来日志文件一样，但是inode编号不一样，所以程序输出的日志还是往原日志文件输出。
3. 通过某些方式通知程序，重新打开日志文件。程序重新打开日志文件，靠的是文件路径而不是inode编号，所以打开的是新的日志文件。

优点：不会丢失数据。

缺点：需要程序支持重新打开日志的功能，如：可以通过信号通知nginx。还有一种方法重开进程，这种方式会影响在线的服务。

2）copytruncate：把正在输出的日志拷(copy)一份出来，再清空(trucate)原来的日志。

优点：对程序无影响

缺点：日志在拷贝完到清空文件这段时间的写入数据将丢失。

总结：能用create的方案就别用copytruncate，很多程序提供了重开日志文件功能来支持create方案，或者自己做了日志滚动，不依赖logrotate。



**logrotate 配置参数说明：**

| 配置参数               | 参数说明                                               |
| ---------------------- | ------------------------------------------------------ |
| daily\|weekly\|monthly | 转储周期 每天\|每周\|每月                              |
| dateext                | 日志切割文件后缀以当前日期结尾，如：messages-20181125  |
| rotate N               | 日志保留N份                                            |
| compress\|nocompress   | 通过gzip压缩转储日志\|不压缩                           |
| copytruncate           | 拷贝日志文件后截断                                     |
| olddir Dir             | 转储日志存放目录，必须和当前日志文件在同一个文件系统。 |

示例：

```shell
## 系统cron默认调用脚本
#!/bin/sh

/usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /home/scripts/logrotate_wallet.conf
EXITVALUE=$?
if [ $EXITVALUE != 0 ]; then
    /usr/bin/logger -t logrotate "ALERT exited abnormally with [$EXITVALUE]"
fi
exit 0

## 钱包服务日志切割
cat /etc/logrotate.d/walletlog
/home/logs/bch/bch.log
/home/logs/btc/btc.log
/home/logs/eos/eos.log
/home/logs/eth/eth.log
/home/logs/ltc/ltc.log
{
daily
copytruncate
dateext
olddir /home/logs/backup
compress
notifempty
rotate 30
}

## 测试
/usr/sbin/logrotate --debug --verbose --force /etc/logrotate.d/walletlog
/usr/sbin/logrotate --force /etc/logrotate.d/walletlog

## tomcat 日志切割
/usr/local/timing/logs/catalina.out
{
daily
copytruncate
dateext
olddir /usr/local/timing/logs/backup
compress
notifempty
rotate 30
}
/usr/sbin/logrotate --force /etc/logrotate.d/timinglog


/var/log/httpd/error_log
/var/log/httpd/access_log
{
daily
copytruncate
dateext
olddir /var/log/httpd/backup
compress
notifempty
rotate 30
}

## 测试

logrotate --debug --verbose --force /var/log/httpd/zabbix
logrotate --force /var/log/httpd/zabbix

## 查看日志切割状态
cat /var/lib/logrotate/logrotate.status
```



## 磁盘

### LVM磁盘在线扩容

相关命令：

`pvcreate`  创建PV

`vgcreate`  创建VG









## Play

### onion深网

#### yum 安装最新 Tor





#### 编译安装指定版本

这里安装 tor 0.2 最新版本：

https://github.com/torproject/tor/archive/tor-0.2.9.17.tar.gz

参考：

<https://github.com/torproject/tor>

<http://www.uwenku.com/question/p-tekklpju-sg.html>

```shell
## 安装编译环境及相关工具
yum install gcc openssl-devel libevent-devel asciidoc automake wget git -y
## 下载 Tor 源码包
wget https://github.com/torproject/tor/archive/tor-0.2.9.17.tar.gz
sh autogen.sh
./configure --prefix=/data/tor --with-tor-user=tor --with-tor-group=tor
make
make test
make install
mv /data/tor/etc/tor/{torrc.sample,torrc}
echo "HiddenServiceDir /var/lib/tor/hidden_service/" >> /data/tor/etc/tor/torrc
echo "HiddenServicePort 80 127.0.0.1:8080" >>/data/tor/etc/tor/torrc
mkdir -p /var/lib/tor/hidden_service
chmod -R 600 /var/lib/tor
## 配置启动文件
cat > /usr/lib/systemd/system/tor.service <<EOF
[Unit]
Description=Anonymizing overlay network for TCP
After=syslog.target network.target nss-lookup.target

[Service]
Type=forking
PidFile=/var/run/tor/tor.pid
NotifyAccess=all
ExecStartPre=/usr/bin/tor -f /data/tor/etc/tor/torrc --verify-config
ExecStart=/usr/bin/tor -f /data/tor/etc/tor/torrc --RunAsDaemon 1
ExecReload=/bin/kill -HUP ${MAINPID}
KillSignal=SIGINT
TimeoutStartSec=120
TimeoutStopSec=60
Restart=on-failure
LimitNOFILE=65536

# Hardening
PrivateTmp=yes
PrivateDevices=yes
ProtectHome=yes
ProtectSystem=full
ReadOnlyDirectories=/
ReadWriteDirectories=-/var/lib/tor
ReadWriteDirectories=-/var/log/tor
NoNewPrivileges=yes
CapabilityBoundingSet=CAP_SETUID CAP_SETGID CAP_NET_BIND_SERVICE CAP_DAC_OVERRIDE CAP_CHOWN CAP_FOWNER

[Install]
WantedBy=multi-user.target
EOF
systemctl start tor
#### 说明 ####
# 如果启动失败，可以手动启动，看具体报错
# 如：/usr/bin/tor -f /data/tor/etc/tor/torrc --RunAsDaemon 1

```




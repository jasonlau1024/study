
# Linux
#### 0001 rm 删除文件空间就释放了吗？

1）为什么 rm 删除一个文件空间没有释放？
因为该文件的应用计数不为0。
1. rm 看似删除了文件，实际上只是将文件引用计数减1，即删除一个文件名到 inode 的链接。
2. 当一个文件的引用计数为0(包括硬链接数)时，才可能调用unlink删除。
3. 当一个程序打开一个文件的时候（获取到文件描述符），它的引用计数会被+1。


2）如何释放已经被删除文件占用的空间？
停止占用该文件的进程即可。
查看`deleted`状态的文件：`lsof |grep deleted` 获取占用进程PID

*补充：*恢复已打开并被删除的文件
```SHELL
# 1.获取占用该文件的进程 PID
lsof |grep deleted |grep 'fortest'
... ...
# 2. 获取改删除文件的fd
ls -al /proc/${PID}/fd
... ...
... 3 -> /root/fortest (deleted)
# 3. 查看文件内容
cat /proc/${PID}/fd/3
# 4. 恢复文件
dd if=/proc/${PID}/fd/3 of=/fortest
```

## OS

### 系统日志
| 日志文件        | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| secure          | 安全相关，主要是用户认证，如登录、创建删除、sudo等           |
| audit/audit.log | 审计日志，跟用户账号相关                                     |
| messages        | 记录系统和软件的绝大多数消息。如服务启动 、停止 、服务错误等。 |
| boot.log        | 系统启动日志。能看到启动流程。                               |
| cron            | 计划任务日志。会记录crontab计划任务的创建、执行信息。        |
| dmesg           | 硬件设备信息(device)                                         |
| lastlog         | 最后登录的日志。用lastlog查看(二进制日志文件)                |
| btmp            | 登录失败的信息(bad)。用lastb查(二进制日志文件)               |
| wtmp            | 正确登录的所有用户命令(who、w)，用last查(二进制日志文件)     |

### TOP命令详解
```SHELL
# top
top - 09:42:32 up 145 days, 16:53,  1 user,  load average: 0.95, 1.12, 1.17
## 当前时间 09:42:32，系统已运行145 days，当前有一个用户登录
## 系统1/5/15分钟的平均负载：0.95, 1.12, 1.17（这里可以看出负载的趋势在下降）
Tasks: 254 total,   2 running, 252 sleeping,   0 stopped,   0 zombie
## Tasks：展示系统运行的整体进程数量和状态信息。
## 系统当前有254个用户进程
## 2个running，252个sleeping，0个僵尸进程
%Cpu(s): 27.9 us,  0.3 sy,  0.0 ni, 71.6 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
## %Cpu(s):CPU的总体使用情况
## 27.9 us，用户态的CPU时间比例，该值很高时，表示CPU时间主要消耗在用户代码
## 0.3 sy，内核态的CPU时间比例，该值很高时，表示CPU时间都消耗在内核，要么是频繁的系统调用，要么是频繁的CPU切换（进程切换/线程切换）
## 71.6 id，空闲CPU时间比例，整体CPU使用率 = 1-id
## 0.3 wa，处于IO等待的CPU时间比例，该值很高时，说明有进程在进程频繁的IO操作，有可能是磁盘IO，也有可能是网络IO。
KiB Mem : 15990592 total,   187024 free,  4793036 used, 11010532 buff/cache
KiB Swap:        0 total,        0 free,        0 used. 10859184 avail Mem
```
补充1.***僵尸进程：***
子进程结束时父进程没有调用wait()/waitpid()等待子进程结束，那么就会产生僵尸进程。原因是子进程结束时并没有真正退出，而是留下一个僵尸进程的数据结构在系统进程表中，等待父进程清理，如果父进程已经退出则会由init进程接替父进程进行处理（收尸）。
影响：僵尸进程太多会导致系统无法创建新的进程，因为进程表的容量是有限的。
解决：干掉僵尸进程的父进程PID（pstress可显示进程父子关系），`kill -9 PID`，父进程退出后init自动会清理僵尸进程。


### 一次完整的浏览器请求
1. 域名解析
2. 建立TCP连接
3. 发起HTTP请求
4. 服务器响应HTTP请求
5. 浏览器解析HTML代码，请求HTML中的资源（如：js、css、图片等）
6. 浏览器对页面进行渲染呈现给用户

#### 域名解析
1. 查找浏览器自身的DNS缓存
2. 查找系统hosts文件以及 OS DNS缓存
3. 访问DNS服务器
4. DNS服务器递归查找域名记录




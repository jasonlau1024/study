


# 安全基础概念
## 安全基本原则
**安全的本质：**
    任何应用最本质的东西其实都是数据，用户使用产品的过程，就是数据交换的过程。从这一层面，安全的本质就是保护数据被合法的使用。
**安全的基本原则：**
CIA三元组：机密性(Confidentiality)、完整性(Integrity)、可用性(Availability)

1）**机密性**
机密性就是确保数据只被授权的主体访问，不被任何未授权的主体访问。即数据"不可见"。

*实现：*安全领域提出了很多访问控制机制和安全模型，对数据和访问主体打上标签或进行分类，并制定相应的访问控制规则去自动进行授权。

*攻防：*直接针对保护技术(加密、隔离、混淆、隐藏等)破解，如：破解加解密算法、逆向混淆代码等，难度是相当高的，这些保护技术普遍都趋于成熟。更多的时候，我们面临的机密性攻击，其实是人为原因导致的疏忽，比如：权限滥用、弱密码、窥屏等。
*总结：*机密性保护的要点是引导人去做正确的事情，避免这类看似低级、实则普遍的漏洞发生。

2）**完整性**
完整性就是确保数据只被授权的主体进行授权的修改。即数据"不可改"。
机密性和完整性是共同出现的，做 好了机密性的保护，基本也意味着做好了完整性的保护。完整性会更加强调对修改行为的审计，主要利用加密、签名等技术，使数据的完整性变得可验证。

3）**可用性**
可用性就是确保数据能够被授权主体访问到。即数据"可读"。
- 运维层面
  物理环境的保护，设备以及服务容冗余，数据备份等
- 研发层面
  降低响应延迟，海量数据处理，高并发场景架构优化等。
- 攻击方式
  如：DoS（Denial of Service，拒绝服务）攻击，通过发送大量的流量来占满带宽资源。


安全防护的目标是进不来，看不见，改不了，拿不走，可追溯。不同的数据安全防护的侧重点不同，根据不同的发展阶段，列好 CIA 的优先级，是我们理解安全问题、定义安全需求、 建设安全体系首先要做的事情。

## 安全解决方案
**黄金法则：**认证（Authentication）、授权（Authorization）、审计 （Audit）
1）**身份识别和认证**
可信的身份认证是建立安全保障体系的第一步，通过多因素认证机制，来加强认证强度。

2）**授权**
授权机制，限制用户操作。

3）**审计和问责**
详细记录用户的操作行为。

## 密码学基础
经典密码学算法：对称加密算法、非对称加密算法和散列算法。






### 对称加密算法
对称加密，双方共用一个密钥加解密数据。（Cline <-- 数据+对称加密算法+密钥A --> Server）

优点：
- 加密解密的速度比较快。

常见对称加密算法：
- DES:(Data Encryption Standard,数据加密标准)，密钥长度56位，已过时，不推荐使用。
- IDEA:（国际数据加密算法，International Data Encryption Algorithm）。密钥长度为 128 位。对比于其他的密码学算法，IDEA 的优势 在于没有专利的限制。
- AES:（高级加密标准，Advanced  Encryption  Standard）。在DES被破解后，美国政府推出了AES算法，提供了128位、192位和256位三种密钥 长度。AES 是目前国际上最认可的密码学算法。
- SM1/SM4（SM1 Cryptographic Algorithm/SM4 Cryptographic Algorithm），国家推出的国密算法。

**常见对称加密算法对比：**

| 算法 | 密钥长度    | 加密强度 | 性能 | 版权             |
| ---- | ----------- | -------- | ---- | ---------------- |
| DES  | 56          | 弱       | 快   | 美国             |
| 3DES | 168         | 中       | 慢   | 美国             |
| IDEA | 128         | 强       | 中   | 瑞士             |
| AES  | 128/192/256 | 强       | 快   | 美国             |
| SM1  | 128         | 强       |      | 中国（算法保密） |
| SM4  | 128         | 强       |      | 中国（算法公开） |

**应用：**
在加密通信中（如 HTTPS、VPN、SSH 等），通信双方会协商出一个加密算法和密钥，对 传输的数据进行加密，从而防止第三方窃取。在类似数据库加密这种存储加密技术中，通信 双方也是将存储空间中的数据进行加密，这样即使硬盘被物理窃取，也不会导致信息丢失。 在公司内部，为了避免用户的 Cookie 和隐私信息发生泄漏，也需要对它们进行加密存储。
对于大部分公司来说，选取 AES128 进行加解密运算，就能获得较高的安全性和性能。如 果是金融或政府行业，在涉及国家层面的对抗上，有一定的合规需求，则需要应用国密算 法。

### 非对称加密算法
非对称加密，加密和解密使用不同的密钥。
非对称加密主要解决通信双方在对称加密协商密钥安全问题。大部分的非对称算法还提供签名的功能，即私钥加密，公钥解密，以验证发送方的身份。

**常见非对称加密算法：**
- RSA（RSA 加密算法，RSA Algorithm）。RSA 的数学难题是：两个大质数 p、q 相乘的结果 n 很容易计算，但是根据 n 去做质因数 分解得到 p、q，则需要很大的计算量。
- ECC（椭圆加密算法，Elliptic Curve Cryptography）。ECC 是基于椭圆曲线的一个数学难题设计的。目前学术界普遍认为，椭圆曲线的难度高于 大质数难题，160 位密钥的 ECC 加密强度，相当于 1088 位密钥的 RSA。因此，ECC 是目 前国际上加密强度最高的非对称加密算法。
- SM2（SM2 Cryptographic Algorithm）。国密算法 SM2 也是基于椭圆曲线问题设计的，加密强度和国际 标准的 ECC 相当。

**非对称加密算法对比：**（同等密钥长度）

| 算法 | 加密强度 | 密钥生成性能 | 加解密性能 | 版权    |
| ---- | -------- | ------------ | ---------- | ------- |
| RSA  | 弱       | 慢           | 快         | RSA公司 |
| ECC  | 强       | 快           | 慢         | 争议中  |
| SM2  | 强       | 快           | 慢         | 中国    |

**应用：**
非对称加密算法大的优势就是解决密钥分发的问题，现在大部分的认证和签名场景，其实使用的都是非对称加密算法。如：SSH登录、Git 上传等场景中，将自己的公钥上传到服务端，然后由客户端保存私钥。
在需要使用非对称加密的场景（比如多对一认证），推荐使用ECC算法。

### 散列算法
散列算法，最常见的密码学密码，长度固定，唯一性，不可逆。

**常见散列算法：**
- MD5（消息摘要算法，Message-Digest Algorithm 5）。生成一个 128 位的消息摘要，由于本身算法的缺陷，它的唯一性已经被破解了。但是大部分场景下，不会构成安全问题。尽量避免使用该算法。
- SHA（安全散列算法，Secure Hash Algorithm）。和 MD5 相同，虽然 SHA 的唯一性也被破解了，但是这也不会构成 大的安全问题。目前 SHA-256 普遍被认为是相对安全的散列算法，推荐使用该算法。
- SM3（SM3 Cryptographic Algorithm）。加密强度和国际标准的 SHA-256 相当。

*补充：*在使用散列算法的时候，一定要注意加“盐”(一串随机的字符)。拼接之后再进行散列计算。“盐”值越长，安全性就越高。


### 总结
对称加密具备较高的安全性和性能，要 优先考虑。在一对多的场景中（如多人登录服务器），存在密钥分发难题的时候，我们要使 用非对称加密；不需要可逆计算的时候（如存储密码），我们就使用散列算法。
算法选取：对称加密用 AES-CTR、非对称加密用 ECC、散列算 法用 SHA256 加盐。

## 身份认证
- 对外认证：应用登录注册模块
- 对内认证：服务器登录、数据库登录、Git登录、内部管理后台登录等
### 身份认证安全


身份认证面临的威胁：
- 没有认证环节
- 弱密码
- 认证信息泄漏


简单的查看身份信息是否泄漏：https://haveibeenpwned.com/


重放攻击
黑客在窃取到身份凭证（如 Cookie、Session ID）之后，就可以在无密码的情况下完 成认证了。

总结：身份认证面临的威胁其实都是认证信息的泄漏。应用本身就没有认证信息或者认证信息强度比较弱，使得黑客可以通过猜测的方式快速获取认证信息；也有可能是黑客通过一些攻击手段（如窃听等），从用户那获取了认证信息，从而冒充用户进行登录。

身份认证安全：
- 通过制定规章制度强化用户的安全意识。
- 密码强度限制，强制用户定期修改密码，关键操作设置二级密码
- 加密信道防止窃听，如https.
- 升级验证方式，如：手机验证码，人脸指纹等。


### 单点登录
单点登录（Single Sign On，SSO），解决账号统一管理。用户只需要进行一次认证，就可以访问所有的网页、应用和其他产品了。
典型的单点登录解决方案：CAS 流程、JWT、OAuth 和 OpenID。
1）**CAS（Central Authentication Service，集中式认证服务）流程**
CAS 是一个开源的单点登录框架，它不属于某一种单点登录的实现方式，而是提供了一整套完整的落地方案。
流程：
1. 用户访问应用。
2. 应用将用户重定向至认证中心。
3. 认证中心进行用户认证。
4. 返回认证凭证和用户信息给用户。
5. 用户将凭据信息发送给应用。
6. 应用向认证中心验证有效性。
7. 完成认证。
2）**JWT（JSON Web Token）**
JWT 是一种非常轻量级的单点登录流程。它会在客户端保存一个凭 证信息，之后在每一次登录的请求中都带上这个凭证，将其作为登录状态的依据。JWT 的好处在于，不需要应用服务端去额外维护 Cookie 或者 Session。但是，正是因为它 将登录状态落到了客户端，所以我们无法进行注销等操作了。

3）**OAuth（Open Authorization）**
OAuth是一个关于授权（authorization）的开放网络标准。如：通过QQ或微信登录其它应用时所采取的协议。
**流程**
1. 用户打开应用，应用要求用户给予授权。
2. 用户同意给予应用授权。
3. 应用使用上一步获得的授权，向认证服务器申请令牌。
4. 认证服务器对应用进行认证以后，确认无误，同意发放令牌。
5. 应用使用令牌，向资源服务器申请获取资源。
6. 资源服务器确认令牌无误，同意向应用开放资源。

4）**OpenID（Open Identity Document）**
OpenID 和 OAuth 的功能基本一致。但是，OpenID 不提供授权的功能。如：在应用中使用微信支付场景，应用只需收集相关支付信息即可。

## 访问控制
“授权”和“访问控制”其实是同一个概念，都是允许或者禁止某个用户做某 件事情。

### 常见访问控制机制
1）**DAC（Discretionary Access Control，自主访问控制）**
DAC 就是让客体的所有者来定义访问控制规则。
- 访问控制的规则维护完全下发到所有者手上。
- 安全性完全取决于 所有者的个人安全意识。
- 灵活性高，维护成本低。适用于面向用户时使用。
Linux 中采用的就是 DAC，用户可以控制自己的文件能够被谁访问。
2）**role-BAC（role  Based Access Control，基于角色的访问控制）**
role-BAC 就是将主体划分为不同的角色，然后对每个角色的权限进行定义。
role-BAC 是防止权限泛滥，实现小特权原则的经典解决方案。适用于管理员集中管理的时使用，所有的权限都 由管理员进行分配和变更。

3）**rule-BAC（rule Based Access Control，基于规则的访问控制）**
rule-BAC 就是制定某种规则，将主体、请求和客体的信息结合起来进行判定。

rule-BAC 适合在复杂场景下提供访问控制保护，通过定义规则来精准控制请求。如：防火墙规则策略。


4）**MAC（Mandatory Access Control，强制访问控制）**
MAC 是一种基于安全级别标签的访问控制策略。
主体和客体被划分为“秘 密、私人、敏感、公开”这四个级别。MAC 要求对所有的主体和客体都打上对应的标签， 然后根据标签来制定访问控制规则。
MAC 是安全性高的访问控制策略。但它对实施的要求也很高，需要对系统中的所有数据 都进行标记。一般只出现在政府系统中。


**总结①：**DAC 是所有者对客体制定的访问控制策略，role-BAC 是管理员对主体制定 的访问控制策略，而 rule-BAC 可以说是针对请求本身制定的访问控制策略。
**总结②：**在实际工作中，需要将它们进行组合使用。

### 威胁评估的步骤
识别数据、识别攻击、识别漏洞
1）识别数据
安全保护的核心资产就是数据。识别数据的最总目的是，通过数据重要性作为衡量安全投入高低的指标。
2）识别攻击
识别攻击的核心就是，明确什么样的数据有价值被攻击。
3）识别漏洞

**总结：**通过对数据、攻击、漏洞的识别，明确公司面临哪些潜在的威胁，从而去思考解决方案，并推动它的落地。通常来说，我们需要定期（比如每年）对公司进行一 次全面的威胁评估工作，并且随着公司的发展，不断调整安全方案。



# Web安全

## XSS
XSS 攻击（Cross-Site Scripting，跨站脚本攻击）,通过给定异常的输入，黑客可以在你的浏览器中，插入一段恶意的 JavaScript 脚本，从而窃取你的隐私信息或者仿冒你进行操作。

三种XSS攻击：反射型 XSS、基于 DOM 的 XSS 以及持久型 XSS

### 反射型 XSS

反射型 XSS 产生在前后端一体的网页应用中，服务端逻辑会改变终的网页代码。

- 黑客利用XSS漏洞注入JS脚本，如：`http://domain/index.php?search=<script>...</script>`
- 黑客诱导用户点击该链接。
- 服务器拼接该search参数并返回带有恶意脚本的HTML。
- 用户浏览器端执行该JS脚本。

### 基于DOM的XSS
在前后端分离的项目中，虽然服务端无法改变网页代码，但网页本身的 JavaScript 仍然可以改变。通过HTML的 JavaScript 脚本修改DOM功能，实现脚本插入。

### 持久型XSS
黑客将恶意的 JavaScript 脚本写入到了正常的服务端数据库中，只要用户正常的使用业务功能，就会被注入 JavaScript 脚本。

## XSS危害及防护
### XSS的危害

- 窃取 Cookie
- 未授权操作
- 按键记录和钓鱼

### XSS的防护
防护的核心原则是：一切用户输入皆不可信。
XSS 防护的核心原则就是验证。
1）验证输入 OR 验证输出
由于验证输入无法保存用户的原始信息，进行溯源。推荐在需要输出展示时进行验证。
HTML中常见XSS注入点：

| 注入点       | 示例                          |
| ------------ | ----------------------------- |
| HTML元素内容 | <div>内容用户</div>           |
| HTML元素属性 | <input value="用户内容">      |
| URL请求参数  | http://domain?search=用户内容 |
| CSS值        | color:用户内容                |
| JavaScript   | var name = "用户内容"         |



2）编码





| 注入点       | 方法                                                         |
| ------------ | ------------------------------------------------------------ |
| HTML元素内容 | node.textContent=用户输入                                    |
| HTML原属属性 | element.setAttribute('input',用户输入)或element['input']=用户输入 |
| URL请求参数  | window.encodeURIComponent(用户输入)                          |
| CSS值        | element.style.color=用户输入                                 |






## SQL注入

## CSRF-SSRF

## 反序列化漏洞

## 信息泄漏

## 插件漏洞

## 权限提升和持久化



# Linux系统和应用安全



# 安全防御工具


# 业务安全





